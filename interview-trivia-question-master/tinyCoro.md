# 协程入门

## 有栈协程和无栈协程

需要注意的是，协程可以按调度的分配来分为：**对称协程和非对称协程**

如果按栈的分配方式又可以分为 **有栈协程和无栈协程**

### 有栈协程

理解有栈协程的时候最好结合 **普通函数调用的栈帧**。当普通函数调用的时候都会生成一个栈帧。

> 一般来说生成的栈帧是，先压入rbp(上一个栈帧的基地址，这样才能返回)，然后更新当前的rbp，再一次压入入参以及函数内部的局部变量。

所以对于普通函数来说，无论是函数的切换还是递归，本质就是栈帧的切换。有栈协程利用的也是这个思想，它分配一个内存空间存储**当前的上下文**，这样就可以手动切换函数，想要恢复函数只要去持有函数上下文的那个内存区域拿出上下文即可。这样的能够自由切换的**有栈协程也是对称协程。**

可以结合linux的`ucontext`库来看这点。u

### 无栈协程

无栈协程可以把协程当作一个类，里面有执行业务逻辑的成员函数，以及记录状态的成员变量。"类"中的成员函数就像状态机，整个函数被分为了几个部分，当遇到某个节点需要切换协程的时候，会改变记录状态的成员变量。当下一次恢复的时候，再次执行"类"的成员函数，就会根据**不同的状态继续执行下一个部分**。我们要做的就是自行实现切换的调度逻辑。

**所有的协程共用的都是一个栈，即系统栈，也就不必自行去给协程分配栈，因为是函数调用，我们当然也不必去显式的保存寄存器的值。**

虽然我们说无栈协程不需要和有栈协程一样为栈信息开辟空间，*无栈协程仍然需要内存空间存储当前状态，只是存储的内容与有栈协程不同*。而且无栈协程属于非对称协程，因此它无法再任意函数调用层级挂起。

c++20是 **无栈协程**。想一下c中通过label-goto这样的方式进行跳转， C++ 协程后大家可以观察到协程的汇编代码存在大量的 label 和 jmp 指令，这正好对应了上述讲到的状态机。



### c++ 协程设计思路

我们之前说了，对于无栈协程，*它是把协程当作一个类，并且在需要切换的地方加入调度点，函数自然就被划分为几个部分*。所以c++协程内置了几个关键字把函数进行切分（其实也就是这个关键字把函数设置了几个调度点）

C++ 的函数包含指定关键字（**co_await，co_yield，co_return**）时，编译器会将其看作协程，而在关键字出现的地方编译器会安插调度点，在调度点用户可以使用协程的方法来指定协程是继续运行还是选择切换执行流程。



> **❓ C++ 协程的创建需要额外的内存，为何说是无栈协程？** C++ 协程不保存栈状态，而是通过对协程状态机的设计，使用了堆内存保存自身运行的某些状态，因此可以理解为仍然需要额外分配内存，但保存的并不是栈结构因此从定义上讲属于无栈协程

> **❓ 怎么理解 C++ 协程是非对称协程？** 在非对称协程中，协程的控制流是单向的，协程让出控制权时只能返回给它的直接调用者。C++20 协程通过 co_await 挂起时，会返回到调用者或恢复者，**而不是直接切换到另一个协程**，而对称协程让出控制权时可以随意指定协程。 在后续的讲解中我们可以看到 C++ 协程可以通过对称转换优化来实现对称协程的行为。