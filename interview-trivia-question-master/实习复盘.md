# IDL编译前端



## idl_compiler

![image-20250903153235881](assets/image-20250903153235881.png)

![image-20250903153301286](assets/image-20250903153301286.png)

![image-20250903153339043](assets/image-20250903153339043.png)

![image-20250903153352582](assets/image-20250903153352582.png)

## idl_lex

![image-20250903153849912](assets/image-20250903153849912.png)

![image-20250903153937002](assets/image-20250903153937002.png)

![image-20250903154005100](assets/image-20250903154005100.png)

![image-20250903154029231](assets/image-20250903154029231.png)

![image-20250903154124230](assets/image-20250903154124230.png)

![image-20250903154216207](assets/image-20250903154216207.png)

![image-20250903154233115](assets/image-20250903154233115.png)

## idl_ir_generator

![image-20250903155131480](assets/image-20250903155131480.png)

![image-20250903155309079](assets/image-20250903155309079.png)

![image-20250903155352154](assets/image-20250903155352154.png)

![image-20250903155412456](assets/image-20250903155412456.png)

![image-20250903155507153](assets/image-20250903155507153.png)

![image-20250903155548265](assets/image-20250903155548265.png)

![image-20250903155620291](assets/image-20250903155620291.png)

![image-20250903155641562](assets/image-20250903155641562.png)

## idl_node

![image-20250903161311838](assets/image-20250903161311838.png)

![image-20250903161321044](assets/image-20250903161321044.png)

![image-20250903161402453](assets/image-20250903161402453.png)

![image-20250903161454747](assets/image-20250903161454747.png)

![image-20250903161524590](assets/image-20250903161524590.png)

![image-20250903161552687](assets/image-20250903161552687.png)

![image-20250903161626913](assets/image-20250903161626913.png)

![image-20250903161704403](assets/image-20250903161704403.png)

![image-20250903161738049](assets/image-20250903161738049.png)

## idl_parser

![image-20250903162520384](assets/image-20250903162520384.png)

![image-20250903162546028](assets/image-20250903162546028.png)

![image-20250903162609863](assets/image-20250903162609863.png)

![image-20250903162630854](assets/image-20250903162630854.png)

![image-20250903162704694](assets/image-20250903162704694.png)

![image-20250903162741973](assets/image-20250903162741973.png)

![image-20250903162803005](assets/image-20250903162803005.png)

![image-20250903162848092](assets/image-20250903162848092.png)

![image-20250903162927995](assets/image-20250903162927995.png)

![image-20250903163005814](assets/image-20250903163005814.png)

![image-20250903163450082](assets/image-20250903163450082.png)

![image-20250903163516631](assets/image-20250903163516631.png)

![image-20250903163559389](assets/image-20250903163559389.png)

![image-20250903163637429](assets/image-20250903163637429.png)

![image-20250903163709904](assets/image-20250903163709904.png)

![image-20250903163744994](assets/image-20250903163744994.png)

![image-20250903163807624](assets/image-20250903163807624.png)

![image-20250903163846940](assets/image-20250903163846940.png)

![image-20250903163910968](assets/image-20250903163910968.png)

![image-20250903163935126](assets/image-20250903163935126.png)

![image-20250903164003343](assets/image-20250903164003343.png)

## idl_semantic

![image-20250903164223371](assets/image-20250903164223371.png)

![image-20250903164303395](assets/image-20250903164303395.png)

![image-20250903164330989](assets/image-20250903164330989.png)

![image-20250903164348398](assets/image-20250903164348398.png)

## 实习工作描述

做了一个 **WebIDL 方言** 的编译前端：用 **PLY(lex/yacc)** 把 IDL 源码解析成 **AST**（`IDLNode`），再生成 **IR(JSON 风格字典)**，最后做一遍 **语义分析**（补充同步/异步、对象使用关系等标注），为后续代码生成做准备。

### 整体流水线（从文件到可用 IR）

1. **词法分析（Lexer, PLY-lex）**

   - 定义 token 集合和正则（关键字、标点、标识符、数字、注释等）。
   - 处理空白行号、非法字符；同时实现“特殊/普通注释”的抽取工具，后面会挂到 AST 属性里。

2. **语法分析（Parser, PLY-yacc）**

   - 在 `p_*` 函数的 **docstring** 里用 BNF 写规则（Interface/Mixin/Partial/Enum/Dictionary/Operation/Arguments…）。
   - 在每条规则归约时，构建 **AST 结点 `IDLNode`** 或临时属性对象 `IDLAttribute`，并把它们按父子关系挂起来。
   - 做了几类 **错误恢复** / 友好化处理：
     - `ERROR_REMAP` 把常见 “Unexpected … after …” 的底层错误映射成更友好的提示；
     - 针对 `InterfaceMembers`、`Arguments` 等关键非终结符写了 `…Error` 规则做恢复。

3. **AST 设计（idl_node.py）**

   - 通用结点类型 `IDLNode`：
     - 内部存 `properties` 字典（`NAME/TYPE/VALUE/ERRORS/WARNINGS/FILENAME/LINENO/POSITION`…）；
     - 提供 `AddChildren/SetProperty/GetProperty/Traverse/Tree` 等通用操作；
     - 提供大量 `IsA*()` 辅助判断（`IsAInterface/IsADictionary/IsAEnum/IsAType/IsAKey/IsAExtAttributes`…）。
   - 还有 `IDLSearch` 小类用于遍历和 pretty dump。

4. **IR 生成（idl_ir_generator.py）**

   - 输入 AST 的根结点（`File`），输出一个 **结构化 IR(dict)**：

     ```
     {
       "objectMap": {...},     # 各 Dictionary/Interface 的字段和类型
       "enumMap": {...},       # 枚举及成员
       "callbackMap": {...},   # 回调类型签名
       "config": config,       # 透传配置
       "apis": [...]           # 从 Interface 提取出来的 API 列表
     }
     ```

   - 核心方法：

     - `__generate_ir` 分派到 `dict/enum/interface/callback` 专用生成函数；
     - `__generate_interface_ir` 收集接口名、注释、扩展属性、以及 **Operation** 列表；
     - `__generate_operation_ir` 解析 `comment/arguments/returnType/extAttributesMap`;
     - `__generate_type_ir` 处理 `Typeref/PrimitiveType/FrozenArray/Any/list[...]` 嵌套；
     - `__generate_default_ir` 与 `__pretty_format` 处理常量/默认值(字符串加引号、浮点补 `.0` 等)。

   - 可选落盘：当传入 `dump_ir=True + dump_dir`，把 IR 按 `filename.json` 写到磁盘（`ensure_ascii=False, indent=4`）。

5. **语义分析（idl_semantic_analyser.py）**

   - 输入 **raw IR**，补充/推断额外语义：
     - **同步/异步**：
       - 若扩展属性 `Call` 指定 `asyncCall/syncCall`，直接用；
       - 否则扫描参数是否包含回调类型，**有回调 => 异步**，否则视为同步。
       - 结果写入 `api['isSync']`。
     - **对象使用标记**：
       - 对 **同步 API**：递归分析 **返回类型**，把涉及的对象在 `objectMap` 上标记 `usedInAPIReturn=True`；
       - 对 **异步 API**：递归分析 **回调参数** 的类型，同样做标记；
       - 递归函数 `__recursive_search_object_names(type_name)` 会展开 `list[Type]`、对象成员的嵌套引用。
   - 这一步的产物是“可用于后续代码生成/裁剪”的 **富 IR**。

6. **编译器入口（idl_compiler / parser 集成）**

   - `IDLLexer()` + `yacc.yacc(module=self)` 组装；
   - `ParseText(filename, data)`：先 `lexer.Tokenize`，再 `yacc.parse(lexer=self.lexer)` 得到 AST children，最后包一层 `File` 结点；
   - 交给 `IDLIRGenerator.generate()` 得到 IR，再喂给 `IDLSemanticAnalyser.analyse()` 产出最终 IR；
   - （可选）把 IR dump 成 JSON，供调试或生成器消费。

### 你具体解决了哪些工程问题

- **语法覆盖面**：支持 Interface / Mixin / Partial / Dictionary / Enum / Typedef / Includes / Const / Operation / Arguments / DefaultValue / ExtAttributes 等核心语法单元。
- **注释和扩展属性**：
  - 实现 `ExtractSpecialComment/ExtractComment`，把 `/** … */` 和 `//` 注释提取为结构化信息；
  - `DivideExtAttrsIntoApplicableAndNonApplicable` 把扩展属性分成“可作用于类型/不可作用于类型”两组，后续生成时放入 `extAttributesMap`。
- **错误体验**：除了 `p_error`，还用 `ERROR_REMAP` 提升报错可读性，并在多个非终结符上写了 `…Error` 规则做错误恢复，提升大文件的容错率。
- **IR 规范化**：
  - 统一了 Type 表达（`Typeref/Primitive/FrozenArray/list[...]`）；
  - 默认值做了统一格式化；
  - Interface 的 API 被“拍平”为 `apis` 列表，方便后续生成与统计。
- **语义增强**：自动判断 API 调用方式（同步/异步），并从返回值/回调参数反向标记被“暴露”的对象（可用于后续按需裁剪/生成更小代码）。
- 

### 面试官可能会追问 → 你可以这样答

- **为什么选 PLY？**
   纯 Python、LALR(1) 性能够用；规则写在函数 docstring，团队容易读；生态简单，易集成。
- **`t_\*` / `p_\*` 分别做什么？**
   `t_*` 是正则切 token；`p_*` 写文法并在“归约”时产出 AST/IR 片段；真正的语法写在 `p_*` 的 docstring 里（BNF 风格）。
- **怎么把 lexer 和 parser 连起来？**
   `self.tokens = self.lexer.KnownTokens()` 把 token 列表交给 yacc；`yacc.yacc(module=self)` 扫描 `p_*`；解析时 `yacc.parse(lexer=self.lexer)` 让 parser 从你的 lexer 拉 token。
- **AST 到 IR 的映射关键点？**
   面向使用场景设计了 `objectMap/enumMap/callbackMap/apis`；对 Operation 统一抽出 `name/returnType/arguments/extAttributesMap/comment`；类型/默认值归一化，便于语言后端消费。
- **怎么判定异步？为什么要递归标记对象？**
   根据扩展属性优先判定；缺省回退到“是否出现回调类型”。递归标记能找出深层嵌套的对象依赖，避免遗漏（例如 `list<Event>`、`Event` 再引用别的对象）。