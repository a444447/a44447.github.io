# 概念

RPC是远程方法调用，现在RPC已经是分布式系统中重要的通信方式。RPC*允许一个程序调用另一个程序中的函数或方法，而无需了解网络的细节*。因此RPC的出现使得分布式系统中的各个组件之间的通信变得更加简单、高效和可信。

RPC 在很多思想与IPC很像。IPC是进程间通信，常用的技术是 **管道、消息队列、共享内存、信号量、socket等**。

**rpc**最开始的目的就是为了让计算机能够像调用本地方法一样调用远程方法！



![img](E:\githome\a44447.github.io\interview-trivia-question-master\assets\6361e5897dc6985f3898539f63b4ff4b.png)

![image-20250303005124710](E:\githome\a44447.github.io\interview-trivia-question-master\assets\image-20250303005124710.png)

这个图就描述了RPC调用的过程。



## why RPC?

1. 简化远程调用的复杂性

在分布式系统中，服务通常部署在不同的机器和网络中，如果没有RPC，开发人员需要自己实现复杂的网络通信代码：

+ 创建和管理连接
+ 数据的序列化与反序列化
+ 请求和响应的发送与接受
+ 错误处理

RPC对这些底层逻辑进行了封装，开发人员只需要专注于业务逻辑

2. RPC支持微服务架构

微服务架构的目标是，1）将功能拆分为独立的服务，降低模块之间的依赖 2） 各个服务可以独立扩展、部署和更新

但是微服务架构中，不同的服务可能是部署在不同的机器或网络环境，需要高效的通信手段，RPC就提供了：

+ 跨机器调用
+ 通过高效的序列化协议，比如Protobuf优化数据传输
+ 提供可靠性保证，内置重试机制、超时机制，确保服务通信的可靠性。

3. 提升开发效率

+ 抽象通信过程:通过使用RPC、开发人员只需定义远程调用的接口(如方法签名)，无需实现复杂的
  通信逻辑.
+ 统一接口定义:大多数rpc框架(如grpc)提供IDL(接口描述语言)，开发人员只需编写一份接
  口定义，框架会自动生成客户端和服务端代码.
+ 减少出错概率:通过框架封装复杂的通信逻辑，可以减少手动编写网络代码时的错误(如序列化失败、超时处理不当等)

### 实现一个rpc的前置知识

我们实现的rpc框架使用的序列化技术是Protobuf。rpc双方通信时发送的都是固定的结构，发送前用Protobuf把消息结构体二进制序列化，在接收方又把这个消息结构体反序列化。

设计的一个简单消息输出格式是这样的

```protobuf
syntax="proto3";
package Krpc;

message RpcHeader {
	bytes service_name=1;
	bytes method_name=2;
	uint32 args_size=3;
}
```

![image-20250303010841052](E:\githome\a44447.github.io\interview-trivia-question-master\assets\image-20250303010841052.png)

因为参数是可变的，所以不能直接封装进RpcHeader,只能封装参数的数量，然后来解析。



### protobuf学习

