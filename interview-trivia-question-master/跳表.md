

# 跳表

## 一、跳表要解决什么问题？

1. **普通链表的问题**
   - 链表是有序的，但只能顺序遍历。
   - 查找/插入/删除一个元素的时间复杂度是 **O(n)**。
2. **平衡树的对比**
   - AVL 树、红黑树能做到 **O(log n)** 查找，但实现复杂，维护平衡代价大。

👉 跳表的目的就是：
 ✅ 在保持链表简单结构的同时，把查找/插入/删除复杂度降到 **O(log n)**，作为平衡树的一种替代方案。

------

## 二、跳表的思想是什么？

核心就是：**在有序链表的基础上，加多级“索引层”，用空间换时间。**

1. **多层索引**

   - 最底层是完整的有序链表。
   - 在此之上，每一层随机抽取一些节点，作为“索引”，指向更下层的节点。
   - 越往上的层，节点越少，跨度越大。

   （直观比喻：就像高速公路有“出口牌子”，不需要看每一个门牌号，先跳大步，再逐层缩小范围。）

2. **查找过程**

   - 从最高层开始，往右走，如果发现“再往右会超过目标值”，就下降一层继续查找。
   - 最终到达底层链表，找到目标元素或者确认不存在。

3. **插入/删除过程**

   - 插入时，先找到位置，再随机决定该节点要不要出现在更高层。
   - 删除时，把该节点在各层的索引都删掉。

4. **随机化维护平衡**

   - 每个节点“向上提升一层”的概率通常是 50%。
   - 这样平均下来，第 i 层的节点数约是第 i-1 层的一半，形成“几何分布”。
   - 因此，跳表的期望高度是 **O(log n)**，操作复杂度也是 **O(log n)**。

------

## 三、总结（面试回答模板）

- **问题**：链表查找是 O(n)，太慢，需要一种既简单又能提升查找效率的数据结构。
- **思想**：在链表上建立多层随机索引，从上到下逐层缩小范围，用空间换时间。
- **效果**：查找/插入/删除的平均复杂度都能降到 O(log n)，实现比平衡树更简单。
- **应用**：Redis 的有序集合（Sorted Set，zset）底层就是用跳表实现的。

# 跳表结构

普通的链表查找元素需要逐一查找，时间复杂度是O(1)，于是就有了跳表。跳表是在链表基础上改的，实现的「多层」有序链表

![image-20250305161714425](https://obsdian-1304266993.cos.ap-chongqing.myqcloud.com/202503051617484.png)

可以看到头节点有三个不同的层级，每个层级的节点也是通过指针连起来的。假如要查找`4`，普通链表需要查找4次，而跳表可以先从L2层级跳到`3`，然后向前一次找到`4`。

在数据量很多的时候，跳表的查找复杂度是O(logN)

https://blog.csdn.net/Zhouzi_heng/article/details/127554294

# 实现

实现的跳表代码在`skiplist.h`头文件中，因此只需要直接include就可以使用。核心结构是`skiplist`结构和`node`结构。

```
template<typename K, typename V> 
class Node {

public:
    
    Node() {} 

    Node(K k, V v, int); 

    ~Node();

    K get_key() const;

    V get_value() const;

    void set_value(V);
    
    // Linear array to hold pointers to next node of different level
    Node<K, V> **forward;

    int node_level;

private:
    K key;
    V value;
};
```

`forward`是一个前向指针数组，也可以理解为`level[]`,`level[0]`是指L0层级的前向指针。

需要注意在初始化的时候`this->forward=new Node<K,V>*[level+1]`,是level+1,因为还有原始的最底层链表。

来看看随机层高函数怎么实现的

```c++
template<typename K, typename V>
int SkipList<K, V>::get_random_level(){
    int level = 1;
    while (rand() % 2) {
        level++;
    }
    k = (k < _max_level) ? k : _max_level; // 最大不超过上限
    return k;
};
```

redis的实现是这样的:

![img](https://i-blog.csdnimg.cn/blog_migrate/fe6a44164ef27ce474a9e6b6a3278f5e.png)

也可以

```c++

private int randomLevel() {
  int level = 1;
  // 当 level < MAX_LEVEL，且随机数小于设定的晋升概率时，level + 1
  while (Math.random() < SKIPLIST_P && level < MAX_LEVEL)
    level += 1;
  return level;
}
//如果想节省点空间，可以降低SKIPLIST_P
//SKIPLIST_P=1/2表示每两个节点抽出一个节点作为上一级索引
```

我们插入的核心在于`update`这个指针数组。它记录了每一层中最后一个满足`key < node.key`的位置。

通过它，我们后续插入新的节点，并且建立它的高层索引的时候，只需要`update[level]`就可以知道新node的第level层索引节点该插入到哪个位置。