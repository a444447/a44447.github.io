---
title: "Day23_动态规划- 第一周"
date: 2024-08-08T10:00:04+08:00
Categories: [算法]
---
动态规划问题的关键点在于状态、状态转移公式。在动态规划中，一个状态是由其上一个状态根据推导公式得到的。在进行动态规划的时候心里一定要自己清楚整个过程。

## 不同路径

{{< blockquote link="https://leetcode.cn/problems/unique-paths/" title="不同路径" author="力扣62" >}}

一个机器人位于一个 `m x n` 网格的左上角 （起始点在下图中标记为 “Start” ）。

机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。

问总共有多少条不同的路径？

 

**示例 1：**

![img](https://pic.leetcode.cn/1697422740-adxmsI-image.png)

```
输入：m = 3, n = 7
输出：28
```

**示例 2：**

```
输入：m = 3, n = 2
输出：3
解释：
从左上角开始，总共有 3 条路径可以到达右下角。
1. 向右 -> 向下 -> 向下
2. 向下 -> 向下 -> 向右
3. 向下 -> 向右 -> 向下
```

**示例 3：**

```
输入：m = 7, n = 3
输出：28
```

**示例 4：**

```
输入：m = 3, n = 3
输出：6
```

 

**提示：**

- `1 <= m, n <= 100`
- 题目数据保证答案小于等于 `2 * 109`

{{< /blockquote >}}

---

这个题的第一个做法就是dfs，但是很容易超时。

下面介绍dp的思想。对于dp问题，我们每次都要想这样几个问题:

+ 确认dp数组与其下标的含义。比如对于这个问题， *dp\[i][j]表示的就是从(0,0)走到(i,j)有几个路径*。
+ 递推公式。这个问题的递推公式很简单，由于题目说了 **只能向右或者向下移动**，那么对于(i,j)，其来路方向只能是上方(i-1,j)或者左边(i,j-1)。因此递推公式就很显见了: $dp[i][j] = dp[i - 1][j] + dp[i][j - 1]$
+ 如何初始化。每个dp问题都要考虑如何初始化数组，对于本题目。我们根据递推公式发现，它公式中的式子，都需要来自其上方或者左边的元素已经先得到了最优解。因此如果我们不初始化最上方与最左方，我们的动态规划的递归公式根本无法执行。

​	至于最上方，也就是`dp[0][j]`，与最左方`dp[i][0]`如何初始化，其实根据观察，要想从(0,0)到(i,0)/(0,j)都只有一条路径

> **注意，这里可能有人会认为从(0,0)->(0,i)等不是可以绕来绕去的到达了，怎么会只有一条路径呢？ 要想达到这个目的，必须是题目说明了能够上下左右移动才行。但是本题中，只有右下移动，故是不可能实现的。**

+ 遍历顺序。在dp问题中，确认遍历顺序也是很重要的，这个问题就不用多说了，肯定是先从左上遍历，也就是从左到右逐行遍历就行。



### 代码

```c++
int uniquePaths(int m, int n) {
        int dp[m][n];
        for (int i = 0; i < n; ++i) dp[0][i] = 1;
        for (int j = 0; j < m; ++j) dp[j][0] = 1;

        for (int i = 1; i < m; ++i) {
            for (int j = 1; j < n; ++j) {
                dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
            }
        }
        return dp[m - 1][n - 1];
    }
```

## 不同的二叉搜索树

{{< blockquote link="https://leetcode.cn/problems/unique-binary-search-trees/" title="不同的二叉搜索树" author="力扣96" >}}

给定一个整数 n，求以 1 ... n 为节点组成的二叉搜索树有多少种？

示例:

![img](https://code-thinking-1253855093.file.myqcloud.com/pics/20210113161941835.png)

{{< /blockquote >}}

---

首先这个题，我们先能够分析出子问题，只有找到了子问题才能够确定能否使用DP。

首先我们要明白，对于一个由`1...n`组成的二叉搜索树，其二叉搜索树数量在这种情况下与数值是没有关系的。比如`1,2,3`组成的二叉搜索树个数与`3,4,5`组成的二叉搜索树数目是一样的。

假设我们求`1...n`的二叉搜索树个数，现在当我们确立了一个根节点`j`后，其二叉树数量等于了`左子树二叉搜索树*右子树二叉搜索树`。而左子树肯定都是小于`j`的，一共有`j - 1 `个，右子树都是大于`j`的，一共有`i - j `个。前面我们提到了它们的二叉搜索树数量与数值无关，因此我们可以转换为求`1,...,j-1` * `1...i-j` 。

现在我们就可以使用我们前面提到的dp算法步骤了。

+ dp[i]表示`1...i`组成的二叉搜索树总个数
+ 递推公式，很明显就是轮流当根节点，然后求每个根节点情况下的二叉搜索树数量，并求和。dp[i] += dp[j - 1] * dp[i - j]
+ 初始化问题，dp[0] = 1
+ 遍历顺序，我们的递推公式告诉我们，后面的i都依赖前面，因此顺序遍历即可。

### 代码

```c++
    int numTrees(int n) {
        vector<int> dp(n + 1);
        dp[1] = 1;
        dp[0] = 1;
        for (int i = 2; i <= n ; ++i) {
            for (int j = 1; j <= i; ++j) {
                dp[i] += dp[i - j] * dp[j - 1];
            }
        }
        return dp[n];
    }
```

