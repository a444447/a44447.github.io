# TCP/IP网络模型

同一个设备上的进程间通信有很多方式，比如管道、共享内存、消息队列、信号等。而不同设备之间的通信就依赖网络协议。

网络协议是分层的，每层有各自的作用。

> 应用层运行在用户态，传输层及以下工作在内核态

## 传输层

传输层,「Transport Layer」是为应用层提供网络支持的。它上面一般运行两个协议，TCP与UDP。

+ TCP是可靠传输的，它实现了很多特性比如拥塞控制、流量控制、超时重传。所以说它是可靠的协议
+ UDP只是负责把数据包发出，但是不保证一定能抵达对方。但是它没有复杂的特性所以它的实时性也更好。



应用要传输的数据可能会很大，一旦传输层的数据包超过了MSS(TCP最大报文长度)，就会吧数据包分块，这样即使中途传输的时候发生损坏或者丢包，也只用传输这个分块——TCP中这个分块叫TCP segment(段)

当设备作为 *接收方* ，传输层要负责把数据包传给应用，但是一个机器上可能有很多个应用在等待接受或者传输数据，这时候就需要用 端口来区分。 传输层的报文中会携带端口号，因此接收方可以识别出这是发给哪个应用的。



## 网络层

传输层负责的事情很单一，就是为上层的应用层提供服务（传递数据，发送数据），它们并不负责将数据从一个设备发送到另一个设备。

实际的传输功能由网络层实现。网络层常用的协议是IP协议。它会把传输层的报文当作数据部分，然后加上自己的IP头组成IP报文——如果IP报文超过了MTU，会再次分片。

![img](/Users/afourseven/blog/interview-trivia-question-master/assets/12.jpg)

世界上有众多的设备，为了找到对方，网络层用IP地址给设备编号。对于IPv4,它是32位的，有两部分：网络号与主机号。

如何找到划分的部分，就要依赖子网掩码（IP地址与子网掩码按位作and运算，得到的就是网络号。

IP协议还负责 **路由**。在实际上，两个设备不可能是通过两个网线直接连接的，其中有很多网关、路由器、交换机。当数据包到达一个网络节点，需要路由算法告诉下一步路经。

## 网络接口层

IP报文接下来会继续交给下层的网络接口层，在IP头部加上MAC头部，封装为数据帧。





## 键入网址到网页显示，期间发生了什么

## linux如何收发网络包？

linux主要是按照TCP/IP网络模型来实现网络协议栈的。

假如应用层有应用数据要发生，它沿着网络栈向下会逐步封装，比如在传输层加上TCP头、网络层又加上IP头...

![img](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost3@main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%B5%AE%E7%82%B9/%E5%B0%81%E8%A3%85.png)

注意这些网络包不是无限大的，因为数据链路不能传输无限大的数据包，在以太网中规定了MTU是1500，超过这个大小的网络包会在网络层分片。如果MTU越小，那么分包越多，网络吞吐能力越差；反之越好。

Linux网络协议栈

<img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost3@main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%B5%AE%E7%82%B9/%E5%8D%8F%E8%AE%AE%E6%A0%88.png" alt="img｜" style="zoom:50%;" />



+ 应用程序是要通过系统调用来和socket层的数据交互。
+ socket层下面是传输层、网络层、网络接口层
+ 最下面是网卡驱动和硬件网卡设备

### 流程

**网卡**是计算机中的一个硬件，负责接收和发送网络包，网卡收到后会通过 **DMA技术**把网络包写入指定的内存地址，也就是ring buffer，这是一个环形缓冲区，然后告诉操作系统这个网络包到达了？

**如何告诉操作系统网络包到达呢？**

一个简单的想法是，只要来有一个网络包到达，网卡就发起一个硬件中断给CPU，让CPU放下手中的事情来处理网络包。但是在有源源不断的网络包到达的场景下，意味着也有源源不断的中断，使得CPU一直在中断中，正常程序无法继续进行。

linux引入了`NAPI`机制，是「中断和轮询」混合的方式来处理网络包——思想是：*不用中断的方式读取数据，而是用中断唤醒一个数据处理与接收的程序，然后以`poll`的方式来轮询数据。*

具体是这样的，网卡通过DMA把数据写到内存，然后发起硬件中断，CPU收到后，根据中断表调用已经注册的中断处理函数

+ 首先函数会「暂时屏蔽中断」，表示知道内存有数据了，下一次有网络包不需要中断CPU了。
+ 然后发起软中断，然后恢复中断。

可以看到硬件中断处理函数要做的事情很少，耗时的部分都给软中断处理函数了。

> 内核中有ksoftirqd线程负责软中断处理，当ksoftirqd收到软中断后，会轮询处理数据，它会从ring buffer中获得一个数据帧，sk_buff,从而交给网络栈逐层处理。

进程网络协议栈后，比如到达网络接口层，就检测报文是否合法，不合法丢弃；合法找出上层协议是ipv4 or ipv6，再丢掉帧头帧尾。再交给网络层。

网络层取出IP包，判断下一步走向，是交给上层还是转发出去。

传输层取出TCP头 or UDP头，根据四元组「源ip,源port,目的ip,目的port」作为标识，找出对应的socket,，把数据放到对应socket的接受缓冲区。

最后应用层程序调用socket接口，将内核的socket接收缓冲区的数据「拷贝」到应用层缓冲区，然后唤醒用户进程。

<img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost3@main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%B5%AE%E7%82%B9/%E6%94%B6%E5%8F%91%E6%B5%81%E7%A8%8B.png" alt="img" style="zoom:67%;" />

那么 **发送流程是怎么样的**

应用程序调用socket的发送数据包的接口，这是一个系统调用，所以程序从用户态陷入内核态，在内核态中申请一个sk_buff内存，将要发送的数据拷贝到里面，并加入到发送缓冲区。

接下来网络协议栈从socket发送缓冲区取出sk_buff,然后从上向下逐层处理。

如果是TCP传输协议，那么会拷贝一个新的sk_buff副本，因为sk_buff在最终到达网卡完成发送后会被释放掉。但是TCP协议支持重传，所以收到对方ACK之前，sk_buff不能被删除。只有当收到一个ACK后才真正删除。

接着sk_buff添加上了各个层的协议头。（从始至终我们都适用sk_buff在各个层中传输）。

从头到位都适用sk_buff这个结构体来描述所有的网络包，这样也不会发生拷贝，增加头部，去掉头部都是移动指针。

当到达网络层后，网络层会选取路由、填充IP头、netfilter过滤，对超过MTU大小的数据包分片，然后交给下一层。对于网络接口层灰通过ARP获得下一跳的MAC地址，然后对sk_buff填充帧头和帧尾，最后加入到网卡的发送队列。

这些工作完成后，触发软中断告诉网卡驱动程序，有新的网络包需要发送，驱动程序从发送队列读取了sk_buff，挂到ring buffer中，接着映射到网卡可以访问的内存DMA区域。发送完成后，网卡触发硬中断来释放sk_buff与ring buffer中的内存。

**发送的时候，一共有几次内存拷贝？**

第一次，应用程序系统调用的时候，把应用数据拷贝到内核申请的sk_buff中

第二次，在使用TCP前提下，拷贝一个sk_buff副本

第三次，在IP层发现sizeof(sk_buff) > MTU的时候，会申请额外的sk_buff，将原来的sk_buff拷贝为多个小的sk_buff。



# TCP

## TCP三次握手与四次挥手

