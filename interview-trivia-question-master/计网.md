# TCP/IP网络模型

同一个设备上的进程间通信有很多方式，比如管道、共享内存、消息队列、信号等。而不同设备之间的通信就依赖网络协议。

网络协议是分层的，每层有各自的作用。

> 应用层运行在用户态，传输层及以下工作在内核态

## 传输层

传输层,「Transport Layer」是为应用层提供网络支持的。它上面一般运行两个协议，TCP与UDP。

+ TCP是可靠传输的，它实现了很多特性比如拥塞控制、流量控制、超时重传。所以说它是可靠的协议
+ UDP只是负责把数据包发出，但是不保证一定能抵达对方。但是它没有复杂的特性所以它的实时性也更好。



应用要传输的数据可能会很大，一旦传输层的数据包超过了MSS(TCP最大报文长度)，就会吧数据包分块，这样即使中途传输的时候发生损坏或者丢包，也只用传输这个分块——TCP中这个分块叫TCP segment(段)

当设备作为 *接收方* ，传输层要负责把数据包传给应用，但是一个机器上可能有很多个应用在等待接受或者传输数据，这时候就需要用 端口来区分。 传输层的报文中会携带端口号，因此接收方可以识别出这是发给哪个应用的。



## 网络层

传输层负责的事情很单一，就是为上层的应用层提供服务（传递数据，发送数据），它们并不负责将数据从一个设备发送到另一个设备。

实际的传输功能由网络层实现。网络层常用的协议是IP协议。它会把传输层的报文当作数据部分，然后加上自己的IP头组成IP报文——如果IP报文超过了MTU，会再次分片。

![img](/Users/afourseven/blog/interview-trivia-question-master/assets/12.jpg)

世界上有众多的设备，为了找到对方，网络层用IP地址给设备编号。对于IPv4,它是32位的，有两部分：网络号与主机号。

如何找到划分的部分，就要依赖子网掩码（IP地址与子网掩码按位作and运算，得到的就是网络号。

IP协议还负责 **路由**。在实际上，两个设备不可能是通过两个网线直接连接的，其中有很多网关、路由器、交换机。当数据包到达一个网络节点，需要路由算法告诉下一步路经。

## 网络接口层

IP报文接下来会继续交给下层的网络接口层，在IP头部加上MAC头部，封装为数据帧。





## 键入网址到网页显示，期间发生了什么

## linux如何收发网络包？

linux主要是按照TCP/IP网络模型来实现网络协议栈的。

假如应用层有应用数据要发生，它沿着网络栈向下会逐步封装，比如在传输层加上TCP头、网络层又加上IP头...

![img](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost3@main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%B5%AE%E7%82%B9/%E5%B0%81%E8%A3%85.png)

注意这些网络包不是无限大的，因为数据链路不能传输无限大的数据包，在以太网中规定了MTU是1500，超过这个大小的网络包会在网络层分片。如果MTU越小，那么分包越多，网络吞吐能力越差；反之越好。

Linux网络协议栈

<img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost3@main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%B5%AE%E7%82%B9/%E5%8D%8F%E8%AE%AE%E6%A0%88.png" alt="img｜" style="zoom:50%;" />



+ 应用程序是要通过系统调用来和socket层的数据交互。
+ socket层下面是传输层、网络层、网络接口层
+ 最下面是网卡驱动和硬件网卡设备

### 流程

**网卡**是计算机中的一个硬件，负责接收和发送网络包，网卡收到后会通过 **DMA技术**把网络包写入指定的内存地址，也就是ring buffer，这是一个环形缓冲区，然后告诉操作系统这个网络包到达了？

**如何告诉操作系统网络包到达呢？**

一个简单的想法是，只要来有一个网络包到达，网卡就发起一个硬件中断给CPU，让CPU放下手中的事情来处理网络包。但是在有源源不断的网络包到达的场景下，意味着也有源源不断的中断，使得CPU一直在中断中，正常程序无法继续进行。

linux引入了`NAPI`机制，是「中断和轮询」混合的方式来处理网络包——思想是：*不用中断的方式读取数据，而是用中断唤醒一个数据处理与接收的程序，然后以`poll`的方式来轮询数据。*

具体是这样的，网卡通过DMA把数据写到内存，然后发起硬件中断，CPU收到后，根据中断表调用已经注册的中断处理函数

+ 首先函数会「暂时屏蔽中断」，表示知道内存有数据了，下一次有网络包不需要中断CPU了。
+ 然后发起软中断，然后恢复中断。

可以看到硬件中断处理函数要做的事情很少，耗时的部分都给软中断处理函数了。

> 内核中有ksoftirqd线程负责软中断处理，当ksoftirqd收到软中断后，会轮询处理数据，它会从ring buffer中获得一个数据帧，sk_buff,从而交给网络栈逐层处理。

进程网络协议栈后，比如到达网络接口层，就检测报文是否合法，不合法丢弃；合法找出上层协议是ipv4 or ipv6，再丢掉帧头帧尾。再交给网络层。

网络层取出IP包，判断下一步走向，是交给上层还是转发出去。

传输层取出TCP头 or UDP头，根据四元组「源ip,源port,目的ip,目的port」作为标识，找出对应的socket,，把数据放到对应socket的接受缓冲区。

最后应用层程序调用socket接口，将内核的socket接收缓冲区的数据「拷贝」到应用层缓冲区，然后唤醒用户进程。

<img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost3@main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%B5%AE%E7%82%B9/%E6%94%B6%E5%8F%91%E6%B5%81%E7%A8%8B.png" alt="img" style="zoom:67%;" />

那么 **发送流程是怎么样的**

应用程序调用socket的发送数据包的接口，这是一个系统调用，所以程序从用户态陷入内核态，在内核态中申请一个sk_buff内存，将要发送的数据拷贝到里面，并加入到发送缓冲区。

接下来网络协议栈从socket发送缓冲区取出sk_buff,然后从上向下逐层处理。

如果是TCP传输协议，那么会拷贝一个新的sk_buff副本，因为sk_buff在最终到达网卡完成发送后会被释放掉。但是TCP协议支持重传，所以收到对方ACK之前，sk_buff不能被删除。只有当收到一个ACK后才真正删除。

接着sk_buff添加上了各个层的协议头。（从始至终我们都适用sk_buff在各个层中传输）。

从头到位都适用sk_buff这个结构体来描述所有的网络包，这样也不会发生拷贝，增加头部，去掉头部都是移动指针。

当到达网络层后，网络层会选取路由、填充IP头、netfilter过滤，对超过MTU大小的数据包分片，然后交给下一层。对于网络接口层灰通过ARP获得下一跳的MAC地址，然后对sk_buff填充帧头和帧尾，最后加入到网卡的发送队列。

这些工作完成后，触发软中断告诉网卡驱动程序，有新的网络包需要发送，驱动程序从发送队列读取了sk_buff，挂到ring buffer中，接着映射到网卡可以访问的内存DMA区域。发送完成后，网卡触发硬中断来释放sk_buff与ring buffer中的内存。

**发送的时候，一共有几次内存拷贝？**

第一次，应用程序系统调用的时候，把应用数据拷贝到内核申请的sk_buff中

第二次，在使用TCP前提下，拷贝一个sk_buff副本

第三次，在IP层发现sizeof(sk_buff) > MTU的时候，会申请额外的sk_buff，将原来的sk_buff拷贝为多个小的sk_buff。



# TCP

## TCP三次握手与四次挥手

首先看一下TCP头格式

<img src="https://cdn.xiaolincoding.com//mysql/other/format,png-20230309230534096.png" alt="TCP 头格式" style="zoom:50%;" />

**序列号：**建立连接的时候计算机生成的随机数作为初始值，通过SYN包发给对端主机，每发送一次就累加一次该数据字节数大小。*解决网络包乱序问题*

**确认应答号:** 指的是下一次「期望」收到的数据序列号，发送端收到这个确认应答号可以认为在这个序列号之前的所有数据都被正常接收了。*用于解决丢包问题*

**控制位：**

![image-20250310151547577](https://obsdian-1304266993.cos.ap-chongqing.myqcloud.com/202503101515665.png)

TCP是：

+ 面向连接的： 所以它是「一对一的」，不像UDP，一个主机可以同时向多个主机发消息
+ 可靠的：TCP保证报文能达到接受端。
+ 字节流：用户使用TCP传输的时候，消息可能会被操作系统分组为多个TCP报文，如果接收端程序不知道「消息边界」，就无法读出有效的用户消息（TCP拆包粘包）。TCP也是「有序的」，它的前一个报文没有收到的时候即使收到了后面的报文也不会交给应用层处理。

> 什么是连接？
>
> 一个TCP连接需要客户端与服务端达成下面共识：
>
> + socket
> + 序列号
> + 窗口大小

TCP的连接由一个四元组唯一确定\<source ip, source port, dest ip, dest port>

所以当我们说有一个IP的服务端监听了某个端口的时候，它可以接受的最大连接数理论是$客户端IP数 \times 客户端端口数$。

但是实际上linux系统有文件描述符限制（TCP连接也是一个文件），同时连接还会占据内存，连接过多会触发OOM.

### UDP与TCP区别？

<img src="https://cdn.xiaolincoding.com//mysql/other/format,png-20230309230439961.png" alt="UDP 头部格式" style="zoom:50%;" />

UDP利用IP提供「无连接」的通信服务。

<img src="https://obsdian-1304266993.cos.ap-chongqing.myqcloud.com/202503101530455.png" alt="image-20250310153025409" style="zoom:50%;" />

<img src="https://obsdian-1304266993.cos.ap-chongqing.myqcloud.com/202503101531531.png" alt="image-20250310153105495" style="zoom:50%;" />

```
有关TCP是流式传输，UDP是按包传输。
//UDP是不会和前面的数据包拼接在一起的，每个数据包都是独立的，接收方一次必须处理一个完整的数据包
recvfrom(5) //即使完整数据包可能有10字节内容，但是如果只读取5字节的话后面的内容会截断，但是也不能再读了。
//TCP
recv(5)
```

TCP与UDP可以同时使用一个端口，因为它们的协议是相互独立的，不会发生冲突。端口是为了区分不同的服务，操作系统会根据不同的协议来管理端口。所以即使端口号相同，但是协议不同的话也是独立的socket。

<img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/network/port/tcp%E5%92%8Cudp%E6%A8%A1%E5%9D%97.jpeg" alt="img" style="zoom:50%;" />

### TCP连接建立

<img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4/%E7%BD%91%E7%BB%9C/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.drawio.png" alt="TCP 三次握手" style="zoom:50%;" />

连接过程实际上就是状态机的状态转换。

语言描述一下就是：

```
1.一开始服务端与客户端都是close状态
2.服务端某个端口开始监听，进入listen状态
3.客户端发起连接，进行SYN_SENT状态，需要设置SYN标志味,随即初始化序列号client_isn
4.服务端收到SYN报文后，进行SYN_RCVD状态，发送报文设置SYN与ACK标志位，确认号=client_isn+1,随机自己的序列号server_isn
5.客户端收到SYN+ACK报文后，进行ESTABLISHED状态，ACK=server_isn+1，同时这次可以携带数据了
6.服务端收到ACK报文后，进行ESTABLISHED状态
```

**为什么是三次握手？而不是两次，四次？**

RFC793指出，TCP连接使用三次握手的主要原因是: **防止旧的重复的连接初始化造成混乱。**

<img src="https://cdn.xiaolincoding.com//mysql/other/format,png-20230309230525514.png" alt="三次握手避免历史连接" style="zoom:50%;" />

> 如果有一个情况是对于已经建立了的TCP连接，突然客户端宕机了。然后客户端又上线，发送了一个相同四元组的TCP连接请求给服务端（服务端不知道之前宕机过，还是处于ESTABLISHED状态），这时候会发生什么？服务端会发送一个challenge ACK报文，也就是恢复带有正确ACK与seq的报文给客户端。客户端会发现这个和自己想要的ack不符合，就会发出RST报文。

如果TCP只使用两次握手，那么服务端就没有一个中间状态来阻止历史连接。两次握手的情况下，服务端收到一个SYN就进行ESTABLISHED，就可以发送数据了。加入它是因为一个历史连接进入的ESTABLISHED，它返回给客户端SYN+ACK会让客户端发现与期待的ACK不一样，于是发出RST。服务端已经发出了一部分数据了。浪费了资源。





