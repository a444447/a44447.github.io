# 什么是GDB

GDB就是 GNU Debugger,就是GNU软件系统的标准调试器

# 使用

## quick start

```c++
g++ -g main.cpp
//输出a.out
gdb a.out

//通过list 可以得到代码信息
(gdb) list
1       #include <iostream>
2
3       int main () {
4          int a[4]{1, 2, 3, 4};
5          for (int i = 0; i < 4; ++i) {
6               std::cout << i << " ";
7          }
8          std::cout << std::endl;
9       }
//通过b(break) main(函数名)/行号可以打断点
(gdb) b main
Breakpoint 1 at 0x1181: file main.cpp, line 4.
//通过info b可以查看打的断点信息
    (gdb) info b
Num     Type           Disp Enb Address            What
1       breakpoint     keep y   0x0000000000001181 in main() at main.cpp:4
//通过n(next)可以逐行执行
 (gdb) n
5          for (int i = 0; i < 4; ++i) {
//print 可以打印表达式的值

//step 进入函数
    
//set logging on 日志模式，可以记录gdb的输出
```

## 小技巧

+ set logging on 可以开启日志模式，记录gdb输出
+ 设置watchpoint,观察变量的变化

```
(gdb) p &i
$1 = (int *) 0x7fffffffe65c
(gdb) watch *0x7fffffffe65c
Hardware watchpoint 2: *0x7fffffffe65c
(gdb) info watchpoints 
Num     Type           Disp Enb Address            What
2       hw watchpoint  keep y                      *0x7fffffffe65c
(gdb) n
5          int i = 0;
(gdb) n

Hardware watchpoint 2: *0x7fffffffe65c

Old value = 0
New value = 1
```



## 调试coredump

一般我们调试程序都是在程序挂掉了的时候，所以我们大部分时候调试的都是coredump。

> coredump是什么？
>
> Core Dump（核心转储）是一种 **崩溃快照**，当程序由于 **严重错误（如段错误 SIGSEGV）** 终止时，操作系统会生成一个包含 **程序运行时内存状态** 的文件，通常叫做 `core` 或 `core.<PID>`（进程 ID）。
>
> 它的作用是 **帮助开发者调试程序崩溃的原因**，类似于 **汽车黑匣子**，记录了程序崩溃时的所有关键信息。
>
> **Core Dump 里有什么?**
>
> 一个 `core` 文件通常包含：
>
> 1. **程序的内存快照**（所有变量、栈、堆等）
> 2. **崩溃的 CPU 寄存器状态**（例如 `EIP/RIP` 指向哪里）
> 3. **程序执行到的代码位置**
> 4. **所有加载的共享库（`libc.so` 等）**
> 5. **线程 & 进程信息**
> 6. **程序的调用栈（backtrace）**



首先需要使用`ulimit -a`看看`core file`的限制情况
```
core file size          (blocks, -c) 0
data seg size           (kbytes, -d) unlimited
scheduling priority             (-e) 0
file size               (blocks, -f) unlimited
pending signals                 (-i) 31298
max locked memory       (kbytes, -l) 64
max memory size         (kbytes, -m) unlimited
open files                      (-n) 1024
pipe size            (512 bytes, -p) 8
POSIX message queues     (bytes, -q) 819200
real-time priority              (-r) 0
stack size              (kbytes, -s) 8192
cpu time               (seconds, -t) unlimited
max user processes              (-u) 31298
virtual memory          (kbytes, -v) unlimited
file locks                      (-x) unlimited
```

如果是0表示最大允许的大小是0.通过`ulimit -c unlimited`设置为无限制。

注意docker中生成coredump需要额外设置[我的docker随笔24：docker产生coredump文件_docker coredump-CSDN博客](https://blog.csdn.net/subfate/article/details/106799184)

然后执行

```
root@5de2ff47ee39:~/cpp# gdb a.out core.1741452091.a.out.3569 

/***
[Thread debugging using libthread_db enabled]
Using host libthread_db library "/lib/x86_64-linux-gnu/libthread_db.so.1".
Core was generated by `./a.out'.
Program terminated with signal SIGSEGV, Segmentation fault.
***/
```

```
(gdb) bt  # 查看调用栈
(gdb) backtrace
(gdb) frame 2 
(gdb) up
(gdb) down
```





## 如何调试正在运行的环境

比如我们写一个无限循环的代码

```c++
#include <iostream>

void test() {

}

void test_test() {
    std::cout << "j" << std::endl;
}

int main () {
    for (;;) {
        test();
        test_test();
    }
    
}
```

然后以后台运行

```
./a.out &
```

然后查找一下进程号

```
ps -ef | grep a.out
```

然后执行

```
gdb -p PID
```







# git相关

## 查看状态

```
git status  # 查看当前仓库状态
git log  # 查看提交历史
```

## 撤销修改

```c++
git reset HEAD file.cpp  # 取消暂存
```

### 取消commit

```c++
git reset --soft HEAD~1  # 只撤销 commit，保留代码
git reset --hard HEAD~1  # 彻底撤销 commit 和代码修改
```

**`git reset` 和 `git revert` 的区别？**

- `reset` **回到历史版本（破坏性）**，`revert` **创建新的 commit（不破坏历史）**。

## git分支管理

### 创建

```c++
git branch dev  # 创建 dev 分支
git checkout dev  # 切换到 dev 分支
git switch dev  # 也可以用 switch（Git 2.23+）
```

### 合并

```c++
git checkout main
git merge dev  # 合并 dev 到 main
```

### 删除分支

```c++
git branch -d dev  # 删除本地分支
git push origin --delete dev  # 删除远程分支

```

## Git Rebase

### **变基（Rebase）**

```
git rebase main  # 把当前分支变基到 main
```

**和 `merge` 的区别**：

- `merge` **保留所有 commit 历史**。
- `rebase` **让分支历史变得更直线（更干净）**。

✅ **面试可能会问**：

- `git merge` 和 `git rebase` 的区别？
  - `merge` **保留历史**，`rebase` **让历史更清晰**（但会重写 commit）。

`merge` 会创建一个新的合并提交，保留分支的历史记录。

`rebase` 会将提交移到目标分支的顶端，没有合并提交。

## Git Stash（存储未提交修改)

如果你需要 **切换分支但不想提交代码**：

```
git stash  # 暂存当前修改
git checkout main  # 切换分支
git stash pop  # 取出暂存修改
```

✅ **面试可能会问**：

- **如何暂存未提交的修改？**
- **如何取出 `stash`？**
