## 描述c++内存管理

c++源代码经过预处理、编译、汇编、链接后会生成可执行文件。在可执行文件中，假设是linux系统，它就是elf格式，它有代码段（包含了指令和.rodata），然后是.data段是全局变量和静态局部变量（初始化了的），上面是.bss段。.bss段本来是保存未初始化的全局变量和静态局部变量，在没加载前只有.bss大小。使用加载器把可执行文件加载进内存中后，c++程序的内存空间就是最下面有一个不可访问区，然后是文本段，数据段，bss段，堆，mmap,栈。最上面还有内核空间。

**1. ELF 文件结构**

你描述的 ELF 格式是正确的，主要包括：

- **代码段（.text）**：存放程序的机器指令，通常是只读的。
- **.rodata 段**：存放程序中的只读数据，例如字符串常量。
- **.data 段**：存放已初始化的全局变量和静态局部变量。
- **.bss 段**：存放未初始化的全局变量和静态局部变量，在 ELF 文件中只记录大小，不占存储空间。

**2. 程序加载进内存后的结构**

加载到内存后，程序的地址空间布局如下：

- **不可访问区（NULL 页）**：地址空间最低处，一般是 0x0 处，避免野指针访问非法地址。

- **代码段（.text）**：存放可执行指令，一般是只读的。

- 数据段（.data/.bss）

  ：

  - `.data`：存放已初始化的全局/静态变量。
  - `.bss`：存放未初始化的全局/静态变量，在加载时被填充为 0。

- 堆（Heap）

  ：

  - 堆的增长方向是**向上（地址增加）**，由 `malloc/new` 申请，`free/delete` 释放。
  - 由 `brk/sbrk` 或 `mmap` 进行扩展。

- mmap 区（映射区）

  ：

  - 用于动态库、`mmap` 映射的文件、共享内存等。
  - 位置一般在堆和栈之间。

- 栈（Stack）

  ：

  - 栈的增长方向是**向下（地址减少）**。
  - 用于存放局部变量、函数调用栈帧等，由 CPU 的栈指针管理。

- 内核空间

  ：

  - 通常是最高的 1GB（32 位系统）或 128TB（64 位系统）。
  - 用户态程序无法直接访问，需要通过系统调用。

**3. 细节调整**

1. **“使用加载器把可执行文件加载进内存”**
   - 更准确的描述是**操作系统的动态链接器（ld.so）和内核的 execve 机制** 负责加载和解析 ELF 文件，并分配内存。
2. **“bss 段本来是保存未初始化的全局变量和静态局部变量”**
   - `.bss` 段在 ELF 文件中**不占据实际存储空间**，而是在程序加载时，由内核填充为 0。
3. **“最上面还有内核空间”**
   - 这个描述是正确的，但可以更明确地说明：
     - 在 32 位系统上，内核空间通常从 0xC0000000 开始。
     - 在 64 位系统上，用户空间可以占据更大的范围（通常是低 128TB），而内核空间位于高地址。

# 重要系统调用

## 操作系统

### 有关malloc

首先malloc不是一个系统调用，是C的库函数，使用malloc申请内存，主要是有两个方式向操作系统申请堆内存：

1. brk()

   如何是通过brk()系统调用分配堆内存的话，就是用brk()函数将堆顶指针向高地址移动，获得新的内存空间。

2. mmap()

​	mmap()系统调用就是在文件分配区分配一块内存。

```c++
void *mmap(void *addr, size_t length, int prot, int flags, int fd, off_t offset);
//flags：映射区域的特性标志
	MAP_SHARED：​共享映射，对映射区域的修改会同步到文件，其他映射该文件的进程也能看到这些修改
    MAP_PRIVATE：​私有映射，对映射区域的修改不会影响原文件，且其他进程不可见
	MAP_ANONYMOUS：​匿名映射，不与任何文件关联，通常用于分配内存
```



> malloc分配的也是虚拟内存，如果这个被分配的内存没有被访问的话，是不会占用物理内存的。只有当访问的时候，查询页表发现虚拟内存对应的页在页表找不到，于是缺页中断，操作系统建立一个虚拟内存和物理内存之间的映射关系。

对于分配的内存小于`128 bytes`，调用malloc的时候实际上是使用`brk()`系统调用。即使是`malloc(1)`也会分配132字节。然后当使用brk()方式申请的堆内存，调用free释放后，并不会还给操作系统，而是当作了内存池，下一次如果还要分配内存，可以直接从这里面分配。当然程序结束，还是会还给操作系统。

**好处是什么呢？**减少了系统调用（每次申请内存如果都要用系统调用，就要从用户态到内核态，效率低），而且如果之前申请的内存被访问过，那么就已经在页表中与物理内存建立了映射，这样的话又减少了缺页中断的次数。

坏处是什么？在堆空间中，存在内存碎片。

---

如果分配的内存大于`128 bytes`将采用mmap的方式，直接在文件映射区分配一个内存。mmap()系统调用分配的内存，调用free后直接归还操作系统。这样的话，每次调用mmap()分配内存，都需要系统调用，且每次访问都会触发缺页中断。
