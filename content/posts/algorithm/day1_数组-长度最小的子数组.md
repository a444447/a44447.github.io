---
title: "Day1_数组 长度最小的子数组"
date: 2024-05-29T20:23:35+08:00
categories: [算法]
---

{{< blockquote author="力扣209" link="https://leetcode.cn/problems/minimum-size-subarray-sum/" title="长度最小的子数组" >}}

给定一个含有 `n` 个正整数的数组和一个正整数 `target` **。**

找出该数组中满足其总和大于等于 `target` 的长度最小的 **子数组**`[numsl, numsl+1, ..., numsr-1, numsr]` ，并返回其长度**。**如果不存在符合条件的子数组，返回 `0` 。

**提示：**

- `1 <= target <= $10^9$`
- `1 <= nums.length <= $10^5$`
- `1 <= nums[i] <= $10^5$`

{{< /blockquote >}}

```c++
示例 1：

输入：target = 7, nums = [2,3,1,2,4,3]
输出：2
解释：子数组 [4,3] 是该条件下的长度最小的子数组。
示例 2：

输入：target = 4, nums = [1,4,4]
输出：1
示例 3：

输入：target = 11, nums = [1,1,1,1,1,1,1,1]
输出：0
```

---

首先思考 **暴力解法**，显然是使用两个`for`循环，遍历每一个子数组，找到其中长度最小的子数组。

现在考虑另一个在数组中常用的方法 **滑动窗口**

滑动窗口其实也是一种双指针，只不过它操作起来就像在维护一个窗口一样，也就是需要维护窗口的起始位置与终止位置。我们现在想要使用滑动窗口，在一个`for`中遍历所有的子数组。那么这个`for`循环应该遍历的是滑动窗口的 *起始位置* 还是 *终止位置*呢？ 

一般而言是 **终止位置**。因此我们`for`的索引表示的就是滑动窗口的终止位置，现在的思路就是： 定义`i`与`j`分别表示滑动窗口的起始与终止位置，开始时都指向`0`索引，然后不断扩大窗口大小,`也就是移动j`。当[i,j]这个范围的子数组之和大于等于`target`，此时更改起始位置`i++`（因为在当前起始位置`i`的条件下再扩大窗口已经没有意义了，因为已经得到了起始位置为`i`的满足`sum >= target`的最小子数组，为了继续寻找新的结果，应该缩小窗口大小）。重复这个过程，直到`j`位于末尾，且当前的`sum < target`。

{{< notice note >}}

**遍历滑动窗口的终止位置**：更适用于需要动态调整起始位置的场景，例如寻找特定条件的子数组、处理复杂的条件判断等。

**遍历滑动窗口的起始位置**：适用于固定窗口大小的场景，例如计算固定大小窗口的最大和、平均值等。

{{< /notice >}}

### 代码

```c++
int minSubArrayLen(int target, vector<int>& nums) {
        int i = 0;
        int sum = 0;
        int res = 1e5+1;
        for (int j = 0; j < nums.size(); ++j)
        {
            sum += nums[j];
            while(sum >= target) {
                res = min(j - i + 1, res);
                sum -= nums[i++];
            }
        }
        return res == 1e5+1 ? 0 : res;
    }
```

+ 时间复杂度：$O(n)$，其中`n`是数组的长度。指针`i` 和 `j`最多各移动 `n`次。

+ 空间复杂度：$O(1)$。

