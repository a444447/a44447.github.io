# 什么是GDB

GDB就是 GNU Debugger,就是GNU软件系统的标准调试器

## GDB原理

+ **利用 `ptrace` 系统调用控制目标进程**

`ptrace` 是 Linux 提供的一个系统调用，允许一个进程（GDB）**观察和控制另一个进程（目标程序）**。

`ptrace` 可以完成以下操作：

- `PTRACE_ATTACH`：附加到目标进程；
- `PTRACE_CONT`：继续执行目标进程；
- `PTRACE_SINGLESTEP`：单步执行；
- `PTRACE_GETREGS / POKE / PEEK`：读取/修改寄存器或内存。



**断点的原理：修改指令。GDB 设置断点时，会将断点地址的原始指令替换成一个特殊指令 `int3`（0xCC，触发中断）。**

流程如下：

1. GDB 读取目标地址原始指令；
2. 把该地址写入一个中断指令（INT 3）；
3. 程序运行到该地址时触发中断；
4. 内核将控制权交给 GDB；
5. GDB 恢复原指令，暂停程序，允许你查看现场。

**单步执行：依靠 CPU 的单步标志位（Trap Flag）**

GDB 设置 `Trap Flag (TF)` 位，在每条指令后让 CPU 产生一个异常；

这使得 GDB 能在每条指令后暂停程序，实现 `stepi` 等命令；

这也是 `PTRACE_SINGLESTEP` 的底层实现。

**查看变量、内存、寄存器**

**查看变量/内存**：

- 通过 `ptrace(PTRACE_PEEKDATA)` 读取目标进程内存；

**查看/修改寄存器**：

- 使用 `PTRACE_GETREGS / SETREGS` 操作，获取寄存器快照或修改。

**调用栈与符号解析（调试信息）**

- GDB 依赖于编译时生成的 **调试信息（DWARF格式）** 来映射：
  - 地址 → 源代码行号；
  - 变量名 → 内存地址；
  - 函数名 → 地址范围；
- 如果加上 `-g` 编译，GDB 会利用这些信息解析栈帧、变量值等。

## quick start

```c++
g++ -g main.cpp
//输出a.out
gdb a.out

//通过list 可以得到代码信息
(gdb) list
1       #include <iostream>
2
3       int main () {
4          int a[4]{1, 2, 3, 4};
5          for (int i = 0; i < 4; ++i) {
6               std::cout << i << " ";
7          }
8          std::cout << std::endl;
9       }
//通过b(break) main(函数名)/行号可以打断点
(gdb) b main
Breakpoint 1 at 0x1181: file main.cpp, line 4.
//通过info b可以查看打的断点信息
    (gdb) info b
Num     Type           Disp Enb Address            What
1       breakpoint     keep y   0x0000000000001181 in main() at main.cpp:4
//通过n(next)可以逐行执行
 (gdb) n
5          for (int i = 0; i < 4; ++i) {
//print 可以打印表达式的值

//step 进入函数
    
//set logging on 日志模式，可以记录gdb的输出
```

## 小技巧

+ set logging on 可以开启日志模式，记录gdb输出
+ 设置watchpoint,观察变量的变化

```
(gdb) p &i
$1 = (int *) 0x7fffffffe65c
(gdb) watch *0x7fffffffe65c
Hardware watchpoint 2: *0x7fffffffe65c
(gdb) info watchpoints 
Num     Type           Disp Enb Address            What
2       hw watchpoint  keep y                      *0x7fffffffe65c
(gdb) n
5          int i = 0;
(gdb) n

Hardware watchpoint 2: *0x7fffffffe65c

Old value = 0
New value = 1
```



## 调试coredump

一般我们调试程序都是在程序挂掉了的时候，所以我们大部分时候调试的都是coredump。

coredump就是进程崩溃的一瞬间进程在内存中的快照.会把进程此刻的内存,寄存器状态,运行栈等信息转储保存在一个文件里.

> coredump是什么？
>
> Core Dump（核心转储）是一种 **崩溃快照**，当程序由于 **严重错误（如段错误 SIGSEGV）** 终止时，操作系统会生成一个包含 **程序运行时内存状态** 的文件，通常叫做 `core` 或 `core.<PID>`（进程 ID）。
>
> 它的作用是 **帮助开发者调试程序崩溃的原因**，类似于 **汽车黑匣子**，记录了程序崩溃时的所有关键信息。
>
> **Core Dump 里有什么?**
>
> 一个 `core` 文件通常包含：
>
> 1. **程序的内存快照**（所有变量、栈、堆等）
> 2. **崩溃的 CPU 寄存器状态**（例如 `EIP/RIP` 指向哪里）
> 3. **程序执行到的代码位置**
> 4. **所有加载的共享库（`libc.so` 等）**
> 5. **线程 & 进程信息**
> 6. **程序的调用栈（backtrace）**



首先需要使用`ulimit -a`看看`core file`的限制情况
```
core file size          (blocks, -c) 0
data seg size           (kbytes, -d) unlimited
scheduling priority             (-e) 0
file size               (blocks, -f) unlimited
pending signals                 (-i) 31298
max locked memory       (kbytes, -l) 64
max memory size         (kbytes, -m) unlimited
open files                      (-n) 1024
pipe size            (512 bytes, -p) 8
POSIX message queues     (bytes, -q) 819200
real-time priority              (-r) 0
stack size              (kbytes, -s) 8192
cpu time               (seconds, -t) unlimited
max user processes              (-u) 31298
virtual memory          (kbytes, -v) unlimited
file locks                      (-x) unlimited
```

如果是0表示最大允许的大小是0.通过`ulimit -c unlimited`设置为无限制。

注意docker中生成coredump需要额外设置[我的docker随笔24：docker产生coredump文件_docker coredump-CSDN博客](https://blog.csdn.net/subfate/article/details/106799184)

然后执行

```
root@5de2ff47ee39:~/cpp# gdb a.out core.1741452091.a.out.3569 

/***
[Thread debugging using libthread_db enabled]
Using host libthread_db library "/lib/x86_64-linux-gnu/libthread_db.so.1".
Core was generated by `./a.out'.
Program terminated with signal SIGSEGV, Segmentation fault.
***/
```

```
(gdb) bt  # 查看调用栈
(gdb) backtrace
(gdb) frame 2 
(gdb) up
(gdb) down
```

### 调试思路

1. 查看调用堆栈，找到崩溃原因，bt
2. 看到了堆栈后，通过f index进入堆栈。



## 如何调试正在运行的环境

比如我们写一个无限循环的代码

```c++
#include <iostream>

void test() {

}

void test_test() {
    std::cout << "j" << std::endl;
}

int main () {
    for (;;) {
        test();
        test_test();
    }
    
}
```

然后以后台运行

```
./a.out &
```

然后查找一下进程号

```
ps -ef | grep a.out
```

然后执行

```
gdb -p PID
```







# git相关

## 查看状态

```
git status  # 查看当前仓库状态
git log  # 查看提交历史
```

## 撤销修改

```c++
git reset HEAD file.cpp  # 取消暂存
```

### 取消commit

```c++
git reset --soft HEAD~1  # 只撤销 commit，保留代码
git reset --hard HEAD~1  # 彻底撤销 commit 和代码修改
```

**`git reset` 和 `git revert` 的区别？**

- `reset` **回到历史版本（破坏性）**，`revert` **创建新的 commit（不破坏历史）**。

## git分支管理

### 创建

```c++
git branch dev  # 创建 dev 分支
git checkout dev  # 切换到 dev 分支
git switch dev  # 也可以用 switch（Git 2.23+）
```

### 合并

```c++
git checkout main
git merge dev  # 合并 dev 到 main
```

### 删除分支

```c++
git branch -d dev  # 删除本地分支
git push origin --delete dev  # 删除远程分支

```

## Git Rebase

### **变基（Rebase）**

```
git rebase main  # 把当前分支变基到 main
```

**和 `merge` 的区别**：

- `merge` **保留所有 commit 历史**。
- `rebase` **让分支历史变得更直线（更干净）**。

✅ **面试可能会问**：

- `git merge` 和 `git rebase` 的区别？
  - `merge` **保留历史**，`rebase` **让历史更清晰**（但会重写 commit）。

`merge` 会创建一个新的合并提交，保留分支的历史记录。

`rebase` 会将提交移到目标分支的顶端，没有合并提交。

## Git Stash（存储未提交修改)

如果你需要 **切换分支但不想提交代码**：

```
git stash  # 暂存当前修改
git checkout main  # 切换分支
git stash pop  # 取出暂存修改
```

✅ **面试可能会问**：

- **如何暂存未提交的修改？**
- **如何取出 `stash`？**

# CMake

cmake是一个跨平台的自动化构建系统，主要是管理工程的构建过程。通过配置CMakeLists.txt来指导编译和链接过程。

## 基本

```c++
cmake_minimum_required(VERSION x.x): 指定项目需要的最低CMake版本。
project(ProjectName): 定义项目的名称和使用的语言。
add_executable(TargetName source1 source2 ...): 添加一个可执行目标，并指定其源文件。
add_library(TargetName type source1 source2 ...): 添加一个库目标，并指定其类型（静态或动态）和源文件。
find_package(PackageName): 查找并加载外部依赖包。
target_link_libraries(TargetName library1 library2 ...): 指定目标链接的库。
```

+ find_package可以直接找到并且加载库
+ 找到依赖库后，使用target_link_libraries来链接库，并使用target_include_directories添加头文件

在构建比较大型的项目时，使用`add_subdirectory`命令来包含子目录，这样每个子目录可以有其自己的CMakeLists.txt文件来管理其源文件和依赖关系。

## blender-sim CMakeLists.txt实例解析



# Docker

一个完整的docker有以下几个部分组成： 1、docker client，客户端，为用户提供一系列可执行命令，用户用这些命令实现跟 docker daemon 交互；

2、docker daemon，守护进程，一般在宿主主机后台运行，等待接收来自客户端的请求消息；

3、docker image，镜像，镜像run之后就生成为docker容器；

4、docker container，容器，一个系统级别的服务，拥有自己的ip和系统目录结构；运行容器前需要本地存在对应的镜像，如果本地不存在该镜像则就去[镜像仓库](https://zhida.zhihu.com/search?content_id=215228910&content_type=Article&match_order=1&q=镜像仓库&zhida_source=entity)下载。

docker 使用客户端-服务器 (C/S) 架构模式，使用远程api来管理和创建docker容器。docker 容器通过 docker 镜像来创建。容器与镜像的关系类似于面向对象编程中的对象与类。

## 与虚拟机的区别

容器是直接运行在宿主机的内核之上，共享宿主机的内核，但在用户空间实现隔离。传统虚拟机是需要安装整个操作系统的，然后再在上面安装业务应用，启动应用，通常需要几分钟去启动应用，而docker是直接使用镜像来运行业务容器的，其容器启动属于秒级别；

所以可以看到比如一个ubuntu镜像有好多个G，但是docker ubuntu镜像才几百兆.一个完整的Linux操作系统包含Linux内核和rootfs根文件系统，即我们熟悉的`/dev`、`/proc/`、`/bin`等目录。我们平时看到的CentOS除了rootfs，还会选装很多软件，服务，图形桌面等，所以CentOS镜像有好几个G也不足为奇。

而对于容器镜像而言，所有容器都是共享宿主机的Linux 内核的，而对于docker镜像而言，docker镜像只需要提供一个很小的rootfs即可，只需要包含最基本的命令，工具，程序库即可，所有docker镜像才会这么小。

---

**容器的copy on write**

一个新的镜像其实是从 base 镜像一层一层叠加生成的。每安装一个软件，dockerfile中使用`RUN`指令，就会在现有镜像的基础上增加一层，这样一层一层的叠加最后构成整个镜像。所以我们`docker pull`拉取一个镜像的时候会看到docker是一层层拉去的。

分层机构最大的一个好处就是 ： 共享资源。比如：有多个镜像都从相同的 base 镜像构建而来，那么 Docker Host 只需在磁盘上保存一份 base 镜像；同时内存中也只需加载一份 base 镜像，就可以为所有容器服务了。而且镜像的每一层都可以被共享。

我们知道，镜像是分层的，镜像的每一层都可以被共享，同时，镜像是只读的。当一个容器启动时，一个新的可写层被加载到镜像的顶部，这一层通常被称作“容器层”，“容器层”之下的都叫“镜像层”。

所有对容器的改动 - 无论添加、删除、还是修改文件，都只会发生在容器层中，因为只有容器层是可写的，容器层下面的所有镜像层都是只读的。镜像层数量可能会很多，所有镜像层会联合在一起组成一个统一的文件系统。如果不同层中有一个相同路径的文件，比如`/a`，上层的 `/a` 会覆盖下层的`/a`，也就是说**用户只能访问到上层中的文件 `/a`**。在容器层中，**用户看到的是一个叠加之后的文件系统**。

**添加文件时：**在容器中创建文件时，新文件被添加到容器层中。

**读取文件：**在容器中读取某个文件时，Docker 会从上往下依次在各镜像层中查找此文件。一旦找到，立即将其复制到容器层，然后打开并读入内存。

**修改文件：**在容器中修改已存在的文件时，Docker 会从上往下依次在各镜像层中查找此文件。一旦找到，立即将其复制到容器层，然后修改之。

**删除文件：**在容器中删除文件时，Docker 也是从上往下依次在镜像层中查找此文件。找到后，会在容器层中记录下此删除操作。

**只有当需要修改时才复制一份数据，这种特性被称作 Copy-on-Write**。可见，容器层保存的是镜像变化的部分，不会对镜像本身进行任何修改。

### dockerfile 构建镜像的过程

1、首先，创建一个目录用于存放应用程序以及构建过程中使用到的各个文件等；

2、然后，在这个目录下创建一个Dockerfile文件，一般建议Dockerfile的文件名就是Dockerfile；

3、编写Dockerfile文件，编写指令，如，使用`FORM指`令指定基础镜像，`COPY`指令复制文件，`RUN`指令指定要运行的命令，`ENV`设置环境变量，`EXPOSE`指定容器要暴露的端口，`WORKDIR`设置当前工作目录，`CMD`容器启动时运行命令，等等指令构建镜像；

4、Dockerfile编写完成就可以构建镜像了，使用`docker build -t 镜像名:tag .`命令来构建镜像，最后一个点是表示当前目录，docker会默认寻找当前目录下的Dockerfile文件来构建镜像，如果不使用默认，可以使用`-f`参数来指定dockerfile文件，如：`docker build -t 镜像名:tag -f /xx/xxx/Dockerfile`；

5、使用`docker build`命令构建之后，docker就会将当前目录下所有的文件发送给docker daemon，顺序执行Dockerfile文件里的指令，在这过程中会生成临时容器，在临时容器里面安装RUN指定的命令，安装成功后，docker底层会使用类似于`docker commit`命令来将容器保存为镜像，然后删除临时容器，以此类推，一层层的构建镜像，运行临时容器安装软件，直到最后的镜像构建成功。









## docker技术三大核心概念

镜像：镜像是一种轻量级、可执行的独立软件包，它包含运行某个软件所需的所有内容，我们把应用程序和配置依赖打包好形成一个可交付的运行环境(包括代码、运行时需要的库、环境变量和配置文件等)，这个打包好的运行环境就是image镜像文件。

容器：容器是基于镜像创建的，是镜像运行起来之后的一个实例，容器才是真正运行业务程序的地方。如果把镜像比作程序里面的类，那么容器就是对象。

镜像仓库：存放镜像的地方，研发工程师打包好镜像之后需要把镜像上传到镜像仓库中去，然后就可以运行有仓库权限的人拉取镜像来运行容器了。

## k8s

k8s就是一个编排容器的系统，一个可以管理容器应用全生命周期的工具，从创建应用，应用的部署，应用提供服务，扩容缩容应用，应用更新，都非常的方便，而且还可以做到故障自愈，所以，k8s是一个非常强大的容器编排系统。

# linux命令

- 切换用户名：su 用户名
- 修改密码：passwd 用户名
- 文件目录权限修改：chmod命令
- 创建目录：mkdir 目录
- 创建文件：touch 文件
- 列出目录文件：ls、ll
- 搜索文件：find -name “文件名” （还有多种查询文件的方式，比如文件大小、更新时间、文件类型）
- 查看文件类型：file 文件
- 调整路径：cd. 、cd.. 、cd 具体路径
- 查看当前路径：pwd
- 压缩/解压文件：tar -zcvf【待压缩文件】/-zxvf【待解压文件】、gzip
- 复制文件：cp 原文件 目标位置
- 剪切、移动：mv 原文件 目标文件
- 删除文件：rm 【选项】【文件】（选项-f，强制删除）
- 比较文件差异：diff
- 浏览文件：cat、vi、vim、tail、more、head
- 查看文件行数、单词数、字符数：wc -l、-w、-c
- 管道符连接两个或多个命令：tail xxx ｜ gerp xxx
- 搜索文件中内容：grep [选项] [模式] [文件名]
- 安装卸载：rpm
- 查看性能指标：
  - top（cpu、内存等）
  - vmstat(cpu、内存、磁盘等）
  - iostat（i/o读写）
  - sar（cpu等比较全的工具）
  - free（内存使用情况）
  - netstat网络情况
  - ss(netstat替代品)
- 进程查看：ps
- 杀掉进程：kill
- 文件内容剪切：cut
- 粘贴命令：paste
- 排序：sort

## ps详解

ps命令用来列出系统中当前运行的那些进程。ps命令列出的是当前那些进程的快照，就是执行ps命令的那个时刻的那些进程，如果想要动态的显示进程信息，就可以使用**top**命令。

- 1. 运行(正在运行或在运行队列中等待)
  2. 中断(休眠中, 受阻, 在等待某个条件的形成或接受到信号)
  3. 不可中断(收到信号不唤醒和不可运行, 进程必须等待直到有中断发生)
  4. 僵死(进程已终止, 但进程描述符存在, 直到父进程调用wait4()系统调用后释放)
  5. 停止(进程收到SIGSTOP, SIGSTP, SIGTIN, SIGTOU信号后停止运行运行)

ps工具标识进程的5种状态码:

- D 不可中断 uninterruptible sleep (usually IO)
- R 运行 runnable (on run queue)
- S 中断 sleeping
- T 停止 traced or stopped
- Z 僵死 a defunct (”zombie”) process

a 显示所有进程
 -a 显示同一终端下的所有程序
 -A 显示所有进程
 c 显示进程的真实名称
 -N 反向选择
 -e 等于“-A”
 e 显示环境变量
 f 显示程序间的关系
 -H 显示树状结构
 r 显示当前终端的进程
 T 显示当前终端的所有程序
 u 指定用户的所有进程
 -au 显示较详细的资讯
 aux 显示所有包含其他使用者的行程
 -C<命令> 列出指定命令的状况
 --lines<行数> 每页显示的行数
 --width<字符数> 每页显示的字符数
 --help 显示帮助信息
 --version 显示版本显示							
