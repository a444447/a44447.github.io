# 什么是GDB

GDB就是 GNU Debugger,就是GNU软件系统的标准调试器

# 使用

## quick start

```c++
g++ -g main.cpp
//输出a.out
gdb a.out

//通过list 可以得到代码信息
(gdb) list
1       #include <iostream>
2
3       int main () {
4          int a[4]{1, 2, 3, 4};
5          for (int i = 0; i < 4; ++i) {
6               std::cout << i << " ";
7          }
8          std::cout << std::endl;
9       }
//通过b(break) main(函数名)/行号可以打断点
(gdb) b main
Breakpoint 1 at 0x1181: file main.cpp, line 4.
//通过info b可以查看打的断点信息
    (gdb) info b
Num     Type           Disp Enb Address            What
1       breakpoint     keep y   0x0000000000001181 in main() at main.cpp:4
//通过n(next)可以逐行执行
 (gdb) n
5          for (int i = 0; i < 4; ++i) {
//print 可以打印表达式的值

//step 进入函数
    
//set logging on 日志模式，可以记录gdb的输出
```

## 小技巧

+ set logging on 可以开启日志模式，记录gdb输出
+ 设置watchpoint,观察变量的变化

```
(gdb) p &i
$1 = (int *) 0x7fffffffe65c
(gdb) watch *0x7fffffffe65c
Hardware watchpoint 2: *0x7fffffffe65c
(gdb) info watchpoints 
Num     Type           Disp Enb Address            What
2       hw watchpoint  keep y                      *0x7fffffffe65c
(gdb) n
5          int i = 0;
(gdb) n

Hardware watchpoint 2: *0x7fffffffe65c

Old value = 0
New value = 1
```



## 调试coredump

一般我们调试程序都是在程序挂掉了的时候，所以我们大部分时候调试的都是coredump。

> coredump是什么？
>
> Core Dump（核心转储）是一种 **崩溃快照**，当程序由于 **严重错误（如段错误 SIGSEGV）** 终止时，操作系统会生成一个包含 **程序运行时内存状态** 的文件，通常叫做 `core` 或 `core.<PID>`（进程 ID）。
>
> 它的作用是 **帮助开发者调试程序崩溃的原因**，类似于 **汽车黑匣子**，记录了程序崩溃时的所有关键信息。
>
> **Core Dump 里有什么?**
>
> 一个 `core` 文件通常包含：
>
> 1. **程序的内存快照**（所有变量、栈、堆等）
> 2. **崩溃的 CPU 寄存器状态**（例如 `EIP/RIP` 指向哪里）
> 3. **程序执行到的代码位置**
> 4. **所有加载的共享库（`libc.so` 等）**
> 5. **线程 & 进程信息**
> 6. **程序的调用栈（backtrace）**



首先需要使用`ulimit -a`看看`core file`的限制情况
```
core file size          (blocks, -c) 0
data seg size           (kbytes, -d) unlimited
scheduling priority             (-e) 0
file size               (blocks, -f) unlimited
pending signals                 (-i) 31298
max locked memory       (kbytes, -l) 64
max memory size         (kbytes, -m) unlimited
open files                      (-n) 1024
pipe size            (512 bytes, -p) 8
POSIX message queues     (bytes, -q) 819200
real-time priority              (-r) 0
stack size              (kbytes, -s) 8192
cpu time               (seconds, -t) unlimited
max user processes              (-u) 31298
virtual memory          (kbytes, -v) unlimited
file locks                      (-x) unlimited
```

如果是0表示最大允许的大小是0.通过`ulimit -c unlimited`设置为无限制。

注意docker中生成coredump需要额外设置[我的docker随笔24：docker产生coredump文件_docker coredump-CSDN博客](https://blog.csdn.net/subfate/article/details/106799184)

然后执行

```
root@5de2ff47ee39:~/cpp# gdb a.out core.1741452091.a.out.3569 

/***
[Thread debugging using libthread_db enabled]
Using host libthread_db library "/lib/x86_64-linux-gnu/libthread_db.so.1".
Core was generated by `./a.out'.
Program terminated with signal SIGSEGV, Segmentation fault.
***/
```





## 如何调试正在运行的环境

比如我们写一个无限循环的代码

```c++
#include <iostream>

void test() {

}

void test_test() {
    std::cout << "j" << std::endl;
}

int main () {
    for (;;) {
        test();
        test_test();
    }
    
}
```

然后以后台运行

```
./a.out &
```

然后查找一下进程号

```
ps -ef | grep a.out
```

然后执行

```
gdb -p PID
```

