---
title: "Day21_贪心- 第一周"
date: 2024-08-07T09:46:04+08:00
Categories: [算法]
---

贪心算法就是在每一面临 *选择*的时候，都选择 **局部最优解**。比如有一沓钞票，一共可以拿十张，如何拿得最多？当然是每次拿都拿该沓钞票现有的最大面额。

做题的时候，经常不知道该不该用贪心算法，也怀疑贪心算法每次求局部最优对不对。一个方法是通过手动模拟一个过程，然后尝试想想局部最优能否解决，并且如果找不到反例，那么就可以用

**贪心一般是常识性推导加上举反例**。

## 分发饼干

{{< blockquote link="https://leetcode.cn/problems/assign-cookies/" author="力扣455" title="分发饼干" >}}

假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。

对每个孩子 `i`，都有一个胃口值 `g[i]`，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 `j`，都有一个尺寸 `s[j]` 。如果 `s[j] >= g[i]`，我们可以将这个饼干 `j` 分配给孩子 `i` ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。

 

**示例 1:**

```
输入: g = [1,2,3], s = [1,1]
输出: 1
解释: 
你有三个孩子和两块小饼干，3个孩子的胃口值分别是：1,2,3。
虽然你有两块小饼干，由于他们的尺寸都是1，你只能让胃口值是1的孩子满足。
所以你应该输出1。
```

**示例 2:**

```
输入: g = [1,2], s = [1,2,3]
输出: 2
解释: 
你有两个孩子和三块小饼干，2个孩子的胃口值分别是1,2。
你拥有的饼干数量和尺寸都足以让所有孩子满足。
所以你应该输出2.
```

 

**提示：**

- `1 <= g.length <= 3 * 10^4`
- `0 <= s.length <= 3 * 10^4`
- `1 <= g[i], s[j] <= 2^31 - 1`

{{< /blockquote >}}

---

这个题是一个典型的贪心想法:

> 大尺寸的饼干既可以满足胃口大的孩子也可以满足胃口小的孩子，那么就应该优先满足胃口大的。
>
> **这里的局部最优就是大饼干喂给胃口大的，充分利用饼干尺寸喂饱一个，全局最优就是喂饱尽可能多的小孩**。

我们模拟过后感觉没有反例就可以动手开写。

需要注意的问题是，我们是遍历 *饼干*还是便利 *胃口*?

首先看 **遍历饼干的情况**

<img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20230112102848.png" alt="img" style="zoom:50%;" />

可以看到，如果是for控制饼干，因为`index`只有满足`s[i] >= g[j]`的时候才会向前移动，如果饼干一直无法满足胃口，会出现`index`不动，而饼干被遍历完的情况，导致本来可以满足的也无法满足。

所以要遍历`胃口`

### 代码

```c++
    int findContentChildren(vector<int>& g, vector<int>& s) {
        sort(g.begin(),g.end());
        sort(s.begin(),s.end());
        int res{0}, j;
        j = s.size() - 1;
        for (int i = g.size() - 1; i >= 0; --i)
        {
            if (j >= 0 && s[j] >= g[i]) {
                res++;
                j--;
            }
        }
        return res;
    }
```

- 时间复杂度：O(nlogn)
- 空间复杂度：O(1)

## 摆动序列

{{< blockquote link="https://leetcode.cn/problems/wiggle-subsequence/" author="力扣376" title="摆动序列" >}}

如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为 **摆动序列 。**第一个差（如果存在的话）可能是正数或负数。仅有一个元素或者含两个不等元素的序列也视作摆动序列。

- 例如， `[1, 7, 4, 9, 2, 5]` 是一个 **摆动序列** ，因为差值 `(6, -3, 5, -7, 3)` 是正负交替出现的。
- 相反，`[1, 4, 7, 2, 5]` 和 `[1, 7, 4, 5, 5]` 不是摆动序列，第一个序列是因为它的前两个差值都是正数，第二个序列是因为它的最后一个差值为零。

**子序列** 可以通过从原始序列中删除一些（也可以不删除）元素来获得，剩下的元素保持其原始顺序。

给你一个整数数组 `nums` ，返回 `nums` 中作为 **摆动序列** 的 **最长子序列的长度** 。

 

**示例 1：**

```
输入：nums = [1,7,4,9,2,5]
输出：6
解释：整个序列均为摆动序列，各元素之间的差值为 (6, -3, 5, -7, 3) 。
```

**示例 2：**

```
输入：nums = [1,17,5,10,13,15,10,5,16,8]
输出：7
解释：这个序列包含几个长度为 7 摆动序列。
其中一个是 [1, 17, 10, 13, 10, 16, 8] ，各元素之间的差值为 (16, -7, 3, -3, 6, -8) 。
```

**示例 3：**

```
输入：nums = [1,2,3,4,5,6,7,8,9]
输出：2
```

 

**提示：**

- `1 <= nums.length <= 1000`
- `0 <= nums[i] <= 1000`

 

{{< /blockquote >}}

## 最大子序列和

{{< blockquote link="https://leetcode.cn/problems/maximum-subarray/" author="力扣53" title="最大子序列和" >}}

给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。

示例:

- 输入: [-2,1,-3,4,-1,2,1,-5,4]
- 输出: 6
- 解释: 连续子数组  [4,-1,2,1] 的和最大，为  6。

{{< /blockquote >}}

---

这道题的暴力做法就是用两个for循环，把每个位置的子序列都遍历一次然后看最大。

对于贪心的方法，我们可以思考局部的最优解： 假设目前的子序列是`s`，下一个位置是`nums[i]`，如果`sum(s) + nums[i]`是一个负数，那么其后的所有子序列都没有计算的必要了，因为负数永远会带来负效应。因此以`nums[i]`为新位置重新开始。

###  代码

```c++
    int maxSubArray(vector<int>& nums) {
        int res = INT32_MIN;
        int tmp = 0;
        for (int i = 0; i < nums.size(); ++i) {
            tmp += nums[i];
            if (tmp > res) res = tmp;
            if (tmp < 0) tmp = 0;
        }
        return res;
    }
```

- 时间复杂度：O(n)
- 空间复杂度：O(n)

## 买卖股票的最佳时机 II

{{< blockquote link="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/" author="力扣122" title="买卖股票的最佳时机 II" >}}

给你一个整数数组 `prices` ，其中 `prices[i]` 表示某支股票第 `i` 天的价格。

在每一天，你可以决定是否购买和/或出售股票。你在任何时候 **最多** 只能持有 **一股** 股票。你也可以先购买，然后在 **同一天** 出售。

返回 *你能获得的 **最大** 利润* 。

 

**示例 1：**

```
输入：prices = [7,1,5,3,6,4]
输出：7
解释：在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5 - 1 = 4。
随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6 - 3 = 3。
最大总利润为 4 + 3 = 7 。
```

**示例 2：**

```
输入：prices = [1,2,3,4,5]
输出：4
解释：在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5 - 1 = 4。
最大总利润为 4 。
```

**示例 3：**

```
输入：prices = [7,6,4,3,1]
输出：0
解释：在这种情况下, 交易无法获得正利润，所以不参与交易可以获得最大利润，最大利润为 0。
```

 

**提示：**

- `1 <= prices.length <= 3 * 10^4`
- `0 <= prices[i] <= 10^4`

{{< /blockquote >}}

---

假如我们第一天买入，第三天卖出，那么可以这样表达利润: `price[2] - price[0]`，注意这个式子还可以写为`price[2] - price[1] + price[1] - price[0]`，也就是将利润转换为每天的收益累加。因此我们要做就是贪心，我们只关注正收益的买入与卖出，累加起来就是我们的最大收益。

### 代码

```c++
    int maxProfit(vector<int>& prices) {
        int profit{0};
        for (int i = 1; i < prices.size(); i++) {
            if (prices[i] - prices[i - 1] > 0) {
                profit += prices[i] - prices[i - 1];
            }
        }
        return profit;
    }
```

- 时间复杂度：O(n)
- 空间复杂度：O(1)

## 跳跃游戏

{{< blockquote link="https://leetcode.cn/problems/jump-game/" author="力扣55" title="跳跃游戏" >}}

给你一个非负整数数组 `nums` ，你最初位于数组的 **第一个下标** 。数组中的每个元素代表你在该位置可以跳跃的最大长度。

判断你是否能够到达最后一个下标，如果可以，返回 `true` ；否则，返回 `false` 。

 

**示例 1：**

```
输入：nums = [2,3,1,1,4]
输出：true
解释：可以先跳 1 步，从下标 0 到达下标 1, 然后再从下标 1 跳 3 步到达最后一个下标。
```

**示例 2：**

```
输入：nums = [3,2,1,0,4]
输出：false
解释：无论怎样，总会到达下标为 3 的位置。但该下标的最大跳跃长度是 0 ， 所以永远不可能到达最后一个下标。
```

 

**提示：**

- `1 <= nums.length <= 10^4`
- `0 <= nums[i] <= 10^5`

{{< /blockquote >}}

---

题目看起来有很多的思考步骤，比如在一个位置假如`nums[i]=3`，那么到底是走一步、两步还是三步呢？实际上我们只需要确定它能覆盖的最大范围就行了，只要最后的覆盖范围能到达数组末尾，那么我们认为就是true的。

**贪心算法局部最优解：每次取最大跳跃步数（取最大覆盖范围），整体最优解：最后得到整体最大覆盖范围，看是否能到终点**。

<img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20230203105634.png" alt="img" style="zoom:50%;" />

### 代码

```c++
bool canJump(vector<int>& nums) {
        int cover{0};
        if (nums.size() ==  1) return true;
        for (int i = 0; i <= cover; i++) {
            cover = max(i + nums[i], cover);
            if (cover >= (nums.size() - 1)) return true;

        }
        return false;
    }
```

- 时间复杂度: O(n)
- 空间复杂度: O(1)

## 跳跃游戏II

{{< blockquote link="https://leetcode.cn/problems/jump-game-ii/" author="力扣45" title="跳跃游戏II" >}}

给定一个长度为 `n` 的 **0 索引**整数数组 `nums`。初始位置为 `nums[0]`。

每个元素 `nums[i]` 表示从索引 `i` 向前跳转的最大长度。换句话说，如果你在 `nums[i]` 处，你可以跳转到任意 `nums[i + j]` 处:

- `0 <= j <= nums[i]` 
- `i + j < n`

返回到达 `nums[n - 1]` 的最小跳跃次数。生成的测试用例可以到达 `nums[n - 1]`。

 

**示例 1:**

```
输入: nums = [2,3,1,1,4]
输出: 2
解释: 跳到最后一个位置的最小跳跃数是 2。
     从下标为 0 跳到下标为 1 的位置，跳 1 步，然后跳 3 步到达数组的最后一个位置。
```

**示例 2:**

```
输入: nums = [2,3,0,1,4]
输出: 2
```

 

**提示:**

- `1 <= nums.length <= 10^4`
- `0 <= nums[i] <= 1000`
- 题目保证可以到达 `nums[n-1]`

{{< /blockquote >}}

---

这个题和之前的`跳跃游戏I`相比，也是需要考虑最大覆盖的问题。假如我们当前的最大覆盖能够到目的地，那么直接返回answer就行；如果不能够覆盖，也就是当我们走到当前的最大覆盖依然没有到达目的，就 *不得不answer++*，此时我们会扩大我们的最大覆盖。这个扩大的最大覆盖，我们称呼为`nextMaxDistance`，它是我们在遍历当前cover过程中求到的。只有当`i==curMaxDistance && i != n-1`的时候，我们才会更新。

<img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20201201232309103.png" alt="45.跳跃游戏II" style="zoom:50%;" />

### 代码

```c++
    int jump(vector<int>& nums) {
        if (nums.size() == 1) return 0;
        int nextMaxDistance{0};
        int curMaxDistance{0};
        int ans{0};
        for (int i = 0; i < nums.size(); ++i) {
            nextMaxDistance = max(nums[i] + i, nextMaxDistance);
            if (i == curMaxDistance) {
                curMaxDistance = nextMaxDistance;
                ans++;
                if (curMaxDistance >= nums.size() - 1) break;
            }
        }
        return ans;
```

- 时间复杂度: O(n)
- 空间复杂度: O(1)

## K次取反后最大化的数组和

{{< blockquote link="https://leetcode.cn/problems/maximize-sum-of-array-after-k-negations/" author="力扣1005" title="K次取反后最大化的数组和" >}}

给你一个整数数组 `nums` 和一个整数 `k` ，按以下方法修改该数组：

- 选择某个下标 `i` 并将 `nums[i]` 替换为 `-nums[i]` 。

重复这个过程恰好 `k` 次。可以多次选择同一个下标 `i` 。

以这种方式修改数组后，返回数组 **可能的最大和** 。

 

**示例 1：**

```
输入：nums = [4,2,3], k = 1
输出：5
解释：选择下标 1 ，nums 变为 [4,-2,3] 。
```

**示例 2：**

```
输入：nums = [3,-1,0,2], k = 3
输出：6
解释：选择下标 (1, 2, 2) ，nums 变为 [3,1,0,2] 。
```

**示例 3：**

```
输入：nums = [2,-3,-1,5,-4], k = 2
输出：13
解释：选择下标 (1, 4) ，nums 变为 [2,3,-1,5,4] 。
```

 

**提示：**

- `1 <= nums.length <= 10^4`
- `-100 <= nums[i] <= 100`
- `1 <= k <= 10^4`

{{< /blockquote >}}

---

此题的思路很明确：

+ 首先，我们根据贪心，肯定是能把绝对值大的负数变为正数最好。
+ 如果此后k还有，那么应该是对已经全部化为正数的数组中找到最小的那个，把它变号，这样贪心的话是局部最优，也是全局最优。

所以重要的步骤是`sort(begin,end,cmp)`，这个cmp应该是根据绝对值大小自定义的:

```c++
sort(begin,end,[](int a, int b{
    return abs(a) > abs(b);
}))
```

### 代码

```c++
int largestSumAfterKNegations(vector<int>& nums, int k) {
        sort(nums.begin(), nums.end(), [](int a, int b) -> bool {
            return abs(a) > abs(b);
        });
        int sum{0};
        for (int i = 0; i < nums.size(); ++i) {
            if (nums[i] < 0 && k > 0) {
                nums[i] *= -1;
                --k;
            }
        }
        if (k % 2 == 1) nums[nums.size() - 1] *= -1;
        for (auto i : nums) {
            sum += i;
        }
        return sum;
    }
```

- 时间复杂度: O(nlogn)
- 空间复杂度: O(1)

