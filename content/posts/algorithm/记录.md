---
title: "记录"
date: 2024-11-07T21:07:26+08:00
categories: [算法]
---

## 位运算题目

### 190.颠倒二进制位

> 颠倒给定的 32 位无符号整数的二进制位。
> 本题主要是考察基本的二进制操作：

+ 如果要获取当前位的值: `n & 1`; 如果要不断的获取`n`的每一位的值，可以不断让n: `n >> 1`
+ 要给某一个赋值使用: `n | i`;如果要不断的赋值，可以: `n = (n << 1) | i`

### 137.只出现过一次的数字

> 给你一个整数数组 `nums` ，除某个元素仅出现 **一次** 外，其余每个元素都恰出现 **三次 。**请你找出并返回那个只出现了一次的元素。
>
> 你必须设计并实现线性时间复杂度的算法且使用常数级空间来解决此问题。

这个类型的题目最简单的形式就是 *某个元素仅出现 一次外，其余每个元素都恰出现 两次*，这种情况只需要对整个数组执行XOR操作，因为一个数和它本身作XOR答案是0.

而对于上面的这种，是奇数的情况，需要额外思考。我们用ans来代指只出现了过一次的元素，我们现在假设没有这个ans，然后将整个nums数组每个值的每一位都进行累加，比如对于第`i`位，由于每个元素都出现了`三次`,那么第`i`位的值一定能被3整除。

现在加上ans，那么每一位的值的累积和除以3的余数就一定是ans在该位的值。

```c++
int singleNumber(vector<int>& nums) {
        int ans = 0;
        for (int i = 0; i < 32; ++i) {
            int tot = 0;
            for (auto e : nums) {
                tot += ((e >> i) & 1);
            }
            if (tot % 3) {
                ans |= (1 << i);
            }
        }
        return ans;
    }
```

### 201.数字范围按位与

> 给你两个整数 `left` 和 `right` ，表示区间 `[left, right]` ，返回此区间内所有数字 **按位与** 的结果（包含 `left` 、`right` 端点）。


## 堆

### 基本知识

+ 首先堆是一种特殊的树，它是「完全二叉树」
+ 堆中的每个节点都必须 **大于等于/小于等于** （分别对应大顶堆与小顶堆）其子树的每个节点的值。

对于堆的存储方式，可以选择使用数组来存储。

> 比如用index=1来存储根节点，那么对于一般的节点i，左孩子就是i*2,右孩子就是i * 2 + 1， 父节点就是 i / 2

**插入**

在插入元素的过程中，为了保持堆的性质，会有一个调整的过程。

> 比如插入的元素是x,我们需要将x与其父元素father_x比较大小，如果不满足大根堆的性质(比如是大根堆)，我们就要执行交换，直到不存在交换发生。

```c++
void push(int x)
{
  heap[++size] = x;
  int i = n;
  while(i/2>0 && heap[i] > heap[i / 2])
  {
    swap(heap[i], heap[i / 2]);
    i /= 2;
  }
}
```

**删除堆顶元素**

一般的操作是用堆的末尾元素覆盖堆顶，然后删除末尾元素，最后再将末尾元素从上到下按照堆的性质进行比较，到达该去的位置。

```c++
void pop()
{
  heap[1] = heap[size--];
  int i = 1;
  while(true)
  {
    int tmp=i;
    if (i*2<=n && heap[i] < heap[i*2]) tmp = i*2;
    if (i*2 + 1 <= n && heap[tmp] < heap[i*2+1]) tmp = i*2+1;
    if (tmp == i) break;
    i = tmp;
  }
}
```

**值得一提的是，c++中的priority_queue就是用堆实现的**

**原地建堆**

如果我们有一个待排序的数组，我们应该直接使用待排序的数组建堆，具体的操作是： 我们从n/2开始（在完全二叉树中，这是第一个非叶子节点），然后执行**堆化**操作。

**排序**

要对一个已经建好堆的数组排序，比如大顶堆，我们只需要把堆顶与末尾元素交换，然后size--，再进行堆化操作。

---

建堆的复杂度是$O(n)$,堆排序的复杂度是$O(n\log n)$。

堆排序与快排相比有一些区别:

+ 堆排对数据的访问方式是跳跃的，而快排是顺序访问的。堆排序中最重要的就是堆化操作，而这个操作访问数组的下标是跳跃的，不像快排局部顺序访问。
+ 对于同样的数据，在排序过程中，堆排序算法的数据交换次数要多于快速排序。我们在讲排序的时候，提过两个概念，有序度和逆序度。对于基于比较的排序算法来说，整个排序过程就是由两个基本的操作组成的，比较和交换（或移动）。快速排序数据交换的次数不会比逆序度多。

### 295.数据流的中位数

> **中位数**是有序整数列表中的中间值。如果列表的大小是偶数，则没有中间值，中位数是两个中间值的平均值。
>
> - 例如 `arr = [2,3,4]` 的中位数是 `3` 。
> - 例如 `arr = [2,3]` 的中位数是 `(2 + 3) / 2 = 2.5` 。
>
> 实现 MedianFinder 类:
>
> - `MedianFinder() `初始化 `MedianFinder` 对象。
> - `void addNum(int num)` 将数据流中的整数 `num` 添加到数据结构中。
> - `double findMedian()` 返回到目前为止所有元素的中位数。与实际答案相差 `10-5` 以内的答案将被接受。

这题是经典的使用双堆，一个最大堆一个最小堆。我们思考中位数是怎么得到的，如果一个有序数组元素个数是偶数，那么就是取有序数组的中间值；如果是奇数，就是中间值与中间值+1求平均。于是我们就有一个想法，如果我们如果能随时取得中间值和中间值+1，那么我们就能动态的获得中位数了。

于是我们定义：

+ 一个最大堆： 它负责存储整个数组的较小一半的元素，需要求中位数时取top()。
+ 一个最小堆： 它负责存储整个数组较大的一半元素,需要求中位数时取top()。

另外对于奇数的情况，我们规定最大堆能存储 n / 2 + 1数量的元素。

所以当数据流源源不断输入数字时，我们只需要判断它是否小于最大堆的top()，如果小于就加入最大堆，反之加入最小堆。

**加入的过程中，还要考虑平衡的问题，也就是最大堆和最小堆之间的数量差距不能超过1**。如果最大堆的数量大于了minHeap.size() + 1那么就要将top元素放入minHeap；反之如果最小堆元素大于了maxHeap.size()，也要放入top到maxHeap。

```c++

```



## 图的广度优先

### 127.单词接龙

> 字典 `wordList` 中从单词 `beginWord` 到 `endWord` 的 **转换序列** 是一个按下述规格形成的序列 `beginWord -> s1 -> s2 -> ... -> sk`：
>
> - 每一对相邻的单词只差一个字母。
> -  对于 `1 <= i <= k` 时，每个 `si` 都在 `wordList` 中。注意， `beginWord` 不需要在 `wordList` 中。
> - `sk == endWord`
>
> 给你两个单词 `beginWord` 和 `endWord` 和一个字典 `wordList` ，返回 *从 `beginWord` 到 `endWord` 的 **最短转换序列** 中的 **单词数目*** 。如果不存在这样的转换序列，返回 `0` 。

这个题和[433.最小基因变化](https://leetcode.cn/problems/minimum-genetic-mutation/?envType=study-plan-v2&envId=top-interview-150)可以用相同的思路来处理。我们通过`unordered_set`记录已经访问过的组合和字典，因为set里面没有重复的元素。

然后是采用BFS的方法，把当前取出的字符串的每个位置都改变('a' ~ 'z')，注意需要判断是否等于了endword；如果不等于还需要判断是否已经访问过了以及是否在字典中。

```
之前做的时候有个错误，就是仅仅只改变了当前字符串的一个位置的字符值，而正确的做法是要遍历每个位置，将每个位置改变字符后的字符串加入到队列中。
如果按照我之前的想法，比如"abc"，我每次仅仅只改变一个位置，比如index=0,也就是只能得到"bbc","cbc",...。这样的话如"a?c"的情况将永远无法访问到.
```

```c++
int ladderLength(string beginWord, string endWord, vector<string>& wordList) {
        
        unordered_set<string> visited;
        unordered_set<string> wordSet(wordList.begin(), wordList.end());
        if (wordSet.find(endWord) == wordSet.end()) {
            return 0;
        }
        queue<string> q;
…                    }
                }
            }
            ++step;
        }
        return 0;
    }
```



## 区间

