---
title: "记录"
date: 2024-11-07T21:07:26+08:00
categories: [算法]
---

## 位运算题目

### 190.颠倒二进制位

> 颠倒给定的 32 位无符号整数的二进制位。
> 本题主要是考察基本的二进制操作：

+ 如果要获取当前位的值: `n & 1`; 如果要不断的获取`n`的每一位的值，可以不断让n: `n >> 1`
+ 要给某一个赋值使用: `n | i`;如果要不断的赋值，可以: `n = (n << 1) | i`

### 137.只出现过一次的数字

> 给你一个整数数组 `nums` ，除某个元素仅出现 **一次** 外，其余每个元素都恰出现 **三次 。**请你找出并返回那个只出现了一次的元素。
>
> 你必须设计并实现线性时间复杂度的算法且使用常数级空间来解决此问题。

这个类型的题目最简单的形式就是 *某个元素仅出现 一次外，其余每个元素都恰出现 两次*，这种情况只需要对整个数组执行XOR操作，因为一个数和它本身作XOR答案是0.

而对于上面的这种，是奇数的情况，需要额外思考。我们用ans来代指只出现了过一次的元素，我们现在假设没有这个ans，然后将整个nums数组每个值的每一位都进行累加，比如对于第`i`位，由于每个元素都出现了`三次`,那么第`i`位的值一定能被3整除。

现在加上ans，那么每一位的值的累积和除以3的余数就一定是ans在该位的值。

```c++
int singleNumber(vector<int>& nums) {
        int ans = 0;
        for (int i = 0; i < 32; ++i) {
            int tot = 0;
            for (auto e : nums) {
                tot += ((e >> i) & 1);
            }
            if (tot % 3) {
                ans |= (1 << i);
            }
        }
        return ans;
    }
```

### 201.数字范围按位与

> 给你两个整数 `left` 和 `right` ，表示区间 `[left, right]` ，返回此区间内所有数字 **按位与** 的结果（包含 `left` 、`right` 端点）。


## 堆

### 基本知识

+ 首先堆是一种特殊的树，它是「完全二叉树」
+ 堆中的每个节点都必须 **大于等于/小于等于** （分别对应大顶堆与小顶堆）其子树的每个节点的值。

对于堆的存储方式，可以选择使用数组来存储。

> 比如用index=1来存储根节点，那么对于一般的节点i，左孩子就是i*2,右孩子就是i * 2 + 1， 父节点就是 i / 2

**插入**

在插入元素的过程中，为了保持堆的性质，会有一个调整的过程。

> 比如插入的元素是x,我们需要将x与其父元素father_x比较大小，如果不满足大根堆的性质(比如是大根堆)，我们就要执行交换，直到不存在交换发生。

```c++
void push(int x)
{
  heap[++size] = x;
  int i = n;
  while(i/2>0 && heap[i] > heap[i / 2])
  {
    swap(heap[i], heap[i / 2]);
    i /= 2;
  }
}
```

**删除堆顶元素**

一般的操作是用堆的末尾元素覆盖堆顶，然后删除末尾元素，最后再将末尾元素从上到下按照堆的性质进行比较，到达该去的位置。

```c++
void pop()
{
  heap[1] = heap[size--];
  int i = 1;
  while(true)
  {
    int tmp=i;
    if (i*2<=n && heap[i] < heap[i*2]) tmp = i*2;
    if (i*2 + 1 <= n && heap[tmp] < heap[i*2+1]) tmp = i*2+1;
    if (tmp == i) break;
    i = tmp;
  }
}
```

**值得一提的是，c++中的priority_queue就是用堆实现的**

**原地建堆**

如果我们有一个待排序的数组，我们应该直接使用待排序的数组建堆，具体的操作是： 我们从n/2开始（在完全二叉树中，这是第一个非叶子节点），然后执行**堆化**操作。

**排序**

要对一个已经建好堆的数组排序，比如大顶堆，我们只需要把堆顶与末尾元素交换，然后size--，再进行堆化操作。

---

建堆的复杂度是$O(n)$,堆排序的复杂度是$O(n\log n)$。

堆排序与快排相比有一些区别:

+ 堆排对数据的访问方式是跳跃的，而快排是顺序访问的。堆排序中最重要的就是堆化操作，而这个操作访问数组的下标是跳跃的，不像快排局部顺序访问。
+ 对于同样的数据，在排序过程中，堆排序算法的数据交换次数要多于快速排序。我们在讲排序的时候，提过两个概念，有序度和逆序度。对于基于比较的排序算法来说，整个排序过程就是由两个基本的操作组成的，比较和交换（或移动）。快速排序数据交换的次数不会比逆序度多。

### 295.数据流的中位数

> **中位数**是有序整数列表中的中间值。如果列表的大小是偶数，则没有中间值，中位数是两个中间值的平均值。
>
> - 例如 `arr = [2,3,4]` 的中位数是 `3` 。
> - 例如 `arr = [2,3]` 的中位数是 `(2 + 3) / 2 = 2.5` 。
>
> 实现 MedianFinder 类:
>
> - `MedianFinder() `初始化 `MedianFinder` 对象。
> - `void addNum(int num)` 将数据流中的整数 `num` 添加到数据结构中。
> - `double findMedian()` 返回到目前为止所有元素的中位数。与实际答案相差 `10-5` 以内的答案将被接受。

这题是经典的使用双堆，一个最大堆一个最小堆。我们思考中位数是怎么得到的，如果一个有序数组元素个数是偶数，那么就是取有序数组的中间值；如果是奇数，就是中间值与中间值+1求平均。于是我们就有一个想法，如果我们如果能随时取得中间值和中间值+1，那么我们就能动态的获得中位数了。

于是我们定义：

+ 一个最大堆： 它负责存储整个数组的较小一半的元素，需要求中位数时取top()。
+ 一个最小堆： 它负责存储整个数组较大的一半元素,需要求中位数时取top()。

另外对于奇数的情况，我们规定最大堆能存储 n / 2 + 1数量的元素。

所以当数据流源源不断输入数字时，我们只需要判断它是否小于最大堆的top()，如果小于就加入最大堆，反之加入最小堆。

**加入的过程中，还要考虑平衡的问题，也就是最大堆和最小堆之间的数量差距不能超过1**。如果最大堆的数量大于了minHeap.size() + 1那么就要将top元素放入minHeap；反之如果最小堆元素大于了maxHeap.size()，也要放入top到maxHeap。

```c++

```



## 图的广度优先

### 127.单词接龙

> 字典 `wordList` 中从单词 `beginWord` 到 `endWord` 的 **转换序列** 是一个按下述规格形成的序列 `beginWord -> s1 -> s2 -> ... -> sk`：
>
> - 每一对相邻的单词只差一个字母。
> -  对于 `1 <= i <= k` 时，每个 `si` 都在 `wordList` 中。注意， `beginWord` 不需要在 `wordList` 中。
> - `sk == endWord`
>
> 给你两个单词 `beginWord` 和 `endWord` 和一个字典 `wordList` ，返回 *从 `beginWord` 到 `endWord` 的 **最短转换序列** 中的 **单词数目*** 。如果不存在这样的转换序列，返回 `0` 。

这个题和[433.最小基因变化](https://leetcode.cn/problems/minimum-genetic-mutation/?envType=study-plan-v2&envId=top-interview-150)可以用相同的思路来处理。我们通过`unordered_set`记录已经访问过的组合和字典，因为set里面没有重复的元素。

然后是采用BFS的方法，把当前取出的字符串的每个位置都改变('a' ~ 'z')，注意需要判断是否等于了endword；如果不等于还需要判断是否已经访问过了以及是否在字典中。

```
之前做的时候有个错误，就是仅仅只改变了当前字符串的一个位置的字符值，而正确的做法是要遍历每个位置，将每个位置改变字符后的字符串加入到队列中。
如果按照我之前的想法，比如"abc"，我每次仅仅只改变一个位置，比如index=0,也就是只能得到"bbc","cbc",...。这样的话如"a?c"的情况将永远无法访问到.
```

```c++
int ladderLength(string beginWord, string endWord, vector<string>& wordList) {
        
        unordered_set<string> visited;
        unordered_set<string> wordSet(wordList.begin(), wordList.end());
        if (wordSet.find(endWord) == wordSet.end()) {
            return 0;
        }
        queue<string> q;
…                    }
                }
            }
            ++step;
        }
        return 0;
    }
```

### 909.蛇梯棋

> 给你一个大小为 `n x n` 的整数矩阵 `board` ，方格按从 `1` 到 `n2` 编号，编号遵循 [转行交替方式](https://baike.baidu.com/item/牛耕式转行书写法/17195786) ，**从左下角开始** （即，从 `board[n - 1][0]` 开始）的每一行改变方向。
>
> 你一开始位于棋盘上的方格 `1`。每一回合，玩家需要从当前方格 `curr` 开始出发，按下述要求前进：
>
> - 选定目标方格 
>
>   ```
>   next
>   ```
>
>   目标方格的编号在范围 
>
>   ```
>   [curr + 1, min(curr + 6, n2)]
>   ```
>
> 
>
>   - 该选择模拟了掷 **六面体骰子** 的情景，无论棋盘大小如何，玩家最多只能有 6 个目的地。
>
> - 传送玩家：如果目标方格 `next` 处存在蛇或梯子，那么玩家会传送到蛇或梯子的目的地。否则，玩家传送到目标方格 `next` 。 
>
> - 当玩家到达编号 `n2` 的方格时，游戏结束。
>
> 如果 `board[r][c] != -1` ，位于 `r` 行 `c` 列的棋盘格中可能存在 “蛇” 或 “梯子”。那个蛇或梯子的目的地将会是 `board[r][c]`。编号为 `1` 和 `n2` 的方格不是任何蛇或梯子的起点。
>
> 注意，玩家在每次掷骰的前进过程中最多只能爬过蛇或梯子一次：就算目的地是另一条蛇或梯子的起点，玩家也 **不能** 继续移动。
>
> - 举个例子，假设棋盘是 `[[-1,4],[-1,3]]` ，第一次移动，玩家的目标方格是 `2` 。那么这个玩家将会顺着梯子到达方格 `3` ，但 **不能** 顺着方格 `3` 上的梯子前往方格 `4` 。（简单来说，类似飞行棋，玩家掷出骰子点数后移动对应格数，遇到单向的路径（即梯子或蛇）可以直接跳到路径的终点，但如果多个路径首尾相连，也不能连续跳多个路径）
>
> 返回达到编号为 `n2` 的方格所需的最少掷骰次数，如果不可能，则返回 `-1`。

这个题目的核心是要读懂题，实际上board中的元素是表示是否有梯子或者蛇，其他部分都是-1(一开始误以为是像棋盘那种问题，编号1，2，3都是board中的值)。

所谓的编号其实是一个约定好的规则，并不体现在board里面的值上。因此我们处理的时候对于每个编号i，还需要求出它在这个蛇棋中的所处行列。

一般来说我们求r,c的方法都是`r=(i - 1) / n`,`c=(i - 1) % n`，但是这个题目说了是一个转行交替的形式，因此我们需要判断r是否是奇数，如果是奇数那么列就需要转行`c = n - 1 - c `。同样，题目说了起始坐标从左下角开始，因此`r = n - 1 - r`。

剩下的就是用广度搜索。广搜对于这种题目有一个好处，当它遇到第一个能到达$n^2$编号的时候，就是最少步数。

```c++
int snakesAndLadders(vector<vector<int>>& board) {
        int n = board.size();
        vector<bool> visited(n * n, false);
        queue<pair<int, int>> q;
        q.push({1, 0});
        
        while(!q.empty())
        {
            auto tmp = q.front();q.pop();
            for (int i = 1; i <= 6; ++i){
                int next = i + tmp.first;
                if (next > n * n) break;
                int r = (next - 1) / n;
                int c = (next - 1) % n;
                if (r % 2 == 1) {
                    c = n - 1 - c;
                }
                r = n - r - 1;
                if (board[r][c] > 0) {
                    next = board[r][c];
                }
                if (next == n * n) {
                    return tmp.second + 1;
                }
                if (!visited[next]) {
                    visited[next] = true;
                    q.emplace(next, tmp.second + 1);
                }
            }
        }
        return -1;
```



## 区间

## 滑动窗口

首先对于滑动窗口问题，一般有一个比较惯用的套路，就是移动滑动窗口的right，然后当满足条件后开始不断减少窗口大小。

```
int j = 0
for (int i = 0; i < n; ++i)
{
	...
	while(check() && j <= i)
	{
		...
		++j
	}
}
```

### 209.长度最小的子数组

> 给定一个含有 `n` 个正整数的数组和一个正整数 `target` **。**
>
> 找出该数组中满足其总和大于等于 `target` 的长度最小的 **子数组**
>
> `[numsl, numsl+1, ..., numsr-1, numsr]` ，并返回其长度**。**如果不存在符合条件的子数组，返回 `0` 。

这个题就是很经典的滑动窗口：先不断的扩大窗口大小，当满足条件后又开始缩小窗口大小，直到不满足又开始扩大窗口····

```c++
int minSubArrayLen(int target, vector<int>& nums) {
        int i = 0, j = 0;
        int cur = 0;
        int ans = INT_MAX;
        int n = nums.size();
        for(int j = 0;j < n; ++j){
            cur += nums[j];
            while(cur >= target)
            {
                ans = min(ans, j - i + 1);
                cur -= nums[i++];
            }
        }
        return ans == INT_MAX ? 0 : ans;
    }
```

## DP

### 多维DP

首先有些时候我们可以使用 **滚动数组** 把二维数组变成一维数组。前提条件是递归公式中`dp[i][j]`完全由上一个状态`dp[i - 1][?]`推出。

但是需要注意的是，使用滚动数组的时候,遍历`i`的时候，要 **注意遍历顺序**，
