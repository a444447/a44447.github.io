# C++

## 进程和线程的区别，什么时候使用多线程和多进程

+ 进程是资源分配的单位，比如内存空间、文件描述表、环境变量等。进程之间互相隔离
+ 线程是任务调度的单位，线程拥有所属进程的共享资源，拥有独立的程序计数器，寄存器，栈。同一进程下的线程之间切换代价小。**C++中线程崩溃可能导致整个程序崩溃**。

所以多进程适用于需要安全、隔离的场景

多线程使用于一般场景，因为切换上下文代价很小。



## 堆和栈在操作系统上的实现，为什么栈的分配速度比堆快。

1. 栈：栈在进程加载进内存后，由操作系统分配的区域，它负责管理函数调用、局部参数。不需要自己回收内存，操作系统回收

首先在 **线程/进程**创建的时候，操作系统创建一个栈空间。要使用栈只需要移动栈指针。

如何使用栈：

> ```c++
> int add(int a, int b) {
>     return a + b;
> }
> 
> int main() {
>     int a, b;
>     add(a, b);
> }
> ```
>
> 首先进入main()，它的汇编是这样的
>
> ```c++
> main:
>         push    rbp              ; 压入栈底指针
>         mov     rbp, rsp         ; 让 rbp 指向当前栈顶
>         sub     rsp, 16          ; 为局部变量 a 和 b 分配 16 字节的栈空间；
>         mov     edx, DWORD PTR [rbp-8]  ; 读取 b（未初始化）
>         mov     eax, DWORD PTR [rbp-4]  ; 读取 a（未初始化）
>         mov     esi, edx         ; 将 b 传给 esi
>         mov     edi, eax         ; 将 a 传给 edi
>         call    add(int, int)    ; 调用 add(a, b)
>         mov     eax, 0           ; main 返回 0
>         leave                    ; 等价于 `mov rsp, rbp` 和 `pop rbp`
>         ret                      ; 返回
> ```
>
> 其中下面可以叫创建栈帧的过程，也就是**函数调用时分配的内存块，用于存储局部变量、参数、返回地址**。:
>
> ```
> push    rbp      ; ① 保存调用者的 rbp（旧栈帧）
> mov     rbp, rsp ; ② 设置新的栈帧基址
> sub     rsp, N   ; ③ 预留局部变量空间，也就是向下移动栈顶指针（N 由编译器决定） sub是减N,因为栈是从高地址到低地址
> ```
>
> 当执行到`add`函数的时候，调用call指令，将返回地址压栈（call进入前处于的函数的下一个条指令），然后又进入创建栈帧的步骤。注意rsp指针随着push、call、ret、pop的执行会增长/减小。
>
> 函数要退出时，执行`move rsp, rbp`恢复到当前函数的栈底，然后pop rbp，最后ret

2. 堆：堆是动态分配的内存区域，需要手动管理

之所以栈的分配比堆快，是因为栈分配内存只涉及了指针的移动，而堆还需要系统调用(无论是brk,或者mmap)。

## select、poll、epoll的区别

select、poll、epoll都是IO多路复用提供的机制。IO多路复用就是让一个线程可以管理多个IO请求。

首先select/poll没什么本质区别，但是它们存储socket集合的数据结构不一样。select是固定长度BitsMap，而poll是以链表形式。以select为例，它把文件描述符集合拷贝到内核，然后内核通过遍历文件描述符集合的方式来检测是否有网络事件发生。如果有事件发生，重新把整个集合拷贝回用户空间。在用户空间下还需要遍历文件描述符集合才能找到可读可写的socket。

epoll的大概用法是这样的：`epoll_create`创建一个epoll对象`epfd`，然后通过`epoll_ctl`把需要监视的socket放入`epfd`中，然后调用`epoll_wait`等待数据

epoll相比select有很多改进

+ epoll内核里面使用红黑树来跟踪所有待检测的文件描述字，`epoll_ctl`就是把需要监控的socket放入epoll_ctl()中。红黑树的增删查改时间一般是O(logn)。而且相比于`select/poll`它们在内核中没有维护一个像红黑树这样保存所有待检测socket的数据结构，所以它们每次都需要复制整个socket集合给内核。而epoll中在内核维护了红黑树，于是每次只需要传入一个待检测的socket。
+ epoll是 *事件驱动*的，内核里面维护了一个链表来记录就绪事件。当某个socket有事件发生，就会通过 *回调函数*内核将其加入到这个就绪事件列表中。用户调用`epoll_wait`只会返回有事件发生的文件描述个数



epoll支持两种事件触发模式，分别是边缘触发（ET）和水平触发（LT）

+ 边缘触发：当被监控的socket有可读事件发生的时候，服务器端只会从epoll_wait苏醒一次，即使进程没有调用read从内核去读，也只会苏醒一次。因此要抱着一次性将内核缓冲区的数据读取完。
+ 水平触发：当被监控的socket有可读事件发生，服务器会不断从epoll_wait中苏醒。直到内核缓冲区数据被read函数读完才结束。

## new和malloc区别

+ 首先new是c++中的操作符，malloc是c的一个库函数。
+ new会先调用operator new，申请空间后，调用类型的构造函数，最后返回类型的指针，调用析构函数，再调用operator delete。
+ malloc是在堆上分配，new是在自由存储区分配(自由存储区可以是堆、全局/静态存储区等)
+ 如果malloc分配失败返回NULL，而new分配失败返回bad_alloc异常——如果不捕捉这个异常会直接异常退出。

## 虚函数与纯虚函数

## 手写LRU

# 其他问题

## 词频统计

### **1. 有一个文件，存放了很多word，如何做词频统计？如果文件很大呢？**

#### **普通文件（文件适中）：**

对于正常大小的文件，词频统计可以通过以下步骤完成：

1. **读取文件内容**：逐行读取或者一次性读取。
2. **分词**：将每行分割成单词。
3. **统计词频**：使用哈希表（如 Python 的 `dict`）记录每个单词的出现次数。
4. **输出结果**：将统计得到的词频以需要的格式保存或输出。

#### **对于大文件（文件体积太大，无法一次性载入内存）：**

1. **读入分块处理**：逐行或分块读入文件，按块统计词频。
2. **中间结果合并**：使用哈希表合并每次处理后的结果。
3. **分布式计算（可选）**：比如使用MapReduce算法，把文件分块后，先执行map操作，得到中间结果后再使用Redeuce汇总。

### **2. 要找到词频的 Top K，应该用什么数据结构？**

在找到词频的 Top K 单词时，我们需要效率高的数据结构，适合的方式如下：

#### **优先级队列（堆）**

- 使用小顶堆（如 Python 的 `heapq`），可以高效地找到 Top K。
- 优点：相比全局排序，只需维护大小为 `k` 的堆，内存占用小且性能高。
- 原理：
  1. 依次读取词频，存入堆。
  2. 若堆超过大小 `k`，弹出最小值。
  3. 最终堆中即为出现频率前 K 高的单词。

#### **大文件排序**

如果词频文件较大，不能完全载入内存，可以采用外部排序（External Sort）：

1. **分块排序**：将文件分块，每一块加载到内存中排序后写回磁盘。
2. **归并排序**：对所有排好序的分块文件，逐步归并成一个整体有序文件。
