---
title: "Day26_动态规划- 第四次"
date: 2024-08-15T09:41:04+08:00
Categories: [算法] 
---
下面我们将来讨论 *买卖股票的最佳时机*系列任务。

## 买卖股票的最佳时机

{{< blockquote link="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/" title="买卖股票的最佳时机" author="力扣121" >}}

给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。

你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。

返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。

- 示例 1：
- 输入：[7,1,5,3,6,4]
- 输出：5
  解释：在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。
- 示例 2：
- 输入：prices = [7,6,4,3,1]
- 输出：0
  解释：在这种情况下, 没有交易完成, 所以最大利润为 0。

{{< /blockquote >}}

---

这是我们想要讨论的 **买卖股票最佳时机的最简单版本**。

我们分析，在某一天，我们能够选择的操作只有两种:

+ 买股票。
+ 卖股票。如果已经有股票的话。

进一步的，我们可以将在每一天的状态归结为两种：**已有股票的状态与未有股票的状态**。

现在我们这样定义DP数组，dp\[i][2]，表示第i天中状态0 or 1的时候能获得的最大收益（0表示已有股票，1表示未有股票）。

现在分析如何能达到这些状态：

+ 对于状态0： 可能是`dp[i - 1]`也就是前一天本来就是状态0，选择延续；或者是前一天是未有股票，在当天选择了买股票从而进入状态1
+ 对于状态1： 可能是`dp[i - 1]`也就是前一天本来是状态1，选择延续；或者是前一天本来是已有股票，当天选择了卖股票而进入状态2

总结，我们的递推公式就是：
$$
dp[i][0]=max(dp[i - 1][0],-prices[i])\\
dp[i][1]=max(dp[i-1][1],dp[i-1][0] + prices[i])
$$
最终返回的结果就是`max(dp[n - 1][0],dp[n - 1][1])`

---

下面要讨论的是初始化，注意我们以dp\[0]表示第一天的时候，如果第一天选择买了股票，此时的收益肯定是`-prices[i]`；如果选择不买，那收益就是`0`

### 代码

```c++
   int maxProfit(vector<int>& prices) {
        int n = prices.size();
        vector<vector<int>> dp(n, vector<int>(2));
        dp[0][0] = -prices[0];
        dp[0][1] = 0;
        for (int i = 1; i < n; ++i) {
            dp[i][0] = max(dp[i - 1][0],-prices[i]);
            dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] + prices[i]);
        } 
        return max(dp[n - 1][0], dp[n - 1][1]);
    }
```



---

下面来看第一种变形，我们上面的题目要求 *只能交易一次（买入卖出算一次）*，现在我们如果不限制交易次数，最主要的递推公式变化就是，当我们在`持有股票状态时`, 考虑前一天是`未持有状态`我们不能只是写`-prices[0]`而是`dp[i - 1][1] - prices[i]`。原因在于之前只有一次交易，因此在进入`持有股票态`前的dp[i]一定是0.

```c++
int maxProfit(vector<int>& prices) {
        int n = prices.size();
        vector<vector<int>> dp(n, vector<int>(2));
        dp[0][0] = -prices[0];
        dp[0][1] = 0;
        for (int i = 1;i < n; ++i) {
            dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] - prices[i]);
            dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] + prices[i]);
        }
        return max(dp[n - 1][0], dp[n-  1][1]);
    }
```

---

再来一个变种，就是我们允许交易`k`次，又该如何处理？这下，我们把状态扩大，变成了`2*k - 1`

使用二维数组 dp[i][j] ：第i天的状态为j，所剩下的最大现金是dp[i][j]

j的状态表示为：

- 0 表示不操作
- 1 第一次买入
- 2 第一次卖出
- 3 第二次买入
- 4 第二次卖出

...

所以二维dp数组的C++定义为：

```cpp
vector<vector<int>> dp(prices.size(), vector<int>(2 * k + 1, 0));
```

达到dp[i][1]状态，有两个具体操作：

- 操作一：第i天买入股票了，那么dp[i][1] = dp[i - 1][0] - prices[i]
- 操作二：第i天没有操作，而是沿用前一天买入的状态，即：dp[i][1] = dp[i - 1][1]

选最大的，所以 dp[i][1] = max(dp\[i - 1][0] - prices[i], dp\[i - 1][1]);

同理dp\[i][2]也有两个操作：

- 操作一：第i天卖出股票了，那么dp\[i][2] = dp\[i - 1][1] + prices[i]
- 操作二：第i天没有操作，沿用前一天卖出股票的状态，即：dp\[i][2] = dp\[i - 1][2]

所以dp\[i][2] = max(dp\[i - 1][1] + prices[i], dp\[i - 1][2])

同理可以类比剩下的状态，代码如下：

```cpp
for (int j = 0; j < 2 * k - 1; j += 2) {
    dp[i][j + 1] = max(dp[i - 1][j + 1], dp[i - 1][j] - prices[i]);
    dp[i][j + 2] = max(dp[i - 1][j + 2], dp[i - 1][j + 1] + prices[i]);
}
```

**dp数组如何初始化?**

第0天没有操作，这个最容易想到，就是0，即：dp\[0][0] = 0;

第0天做第一次买入的操作，dp\[0][1] = -prices[0];

第0天做第一次卖出的操作，这个初始值应该是多少呢？

此时还没有买入，怎么就卖出呢？ 其实大家可以理解当天买入，当天卖出，所以dp\[0][2] = 0;

第0天第二次买入操作，初始值应该是多少呢？应该不少同学疑惑，第一次还没买入呢，怎么初始化第二次买入呢？

第二次买入依赖于第一次卖出的状态，其实相当于第0天第一次买入了，第一次卖出了，然后在买入一次（第二次买入），那么现在手头上没有现金，只要买入，现金就做相应的减少。

所以第二次买入操作，初始化为：dp\[0][3] = -prices[0];

第二次卖出初始化dp\[0][4] = 0;

**所以同理可以推出dp\[0][j]当j为奇数的时候都初始化为 -prices[0]**

```cpp
for (int j = 1; j < 2 * k; j += 2) {
    dp[0][j] = -prices[0];
}
```

最终代码:
```c++
class Solution {
public:
    int maxProfit(int k, vector<int>& prices) {

        if (prices.size() == 0) return 0;
        vector<vector<int>> dp(prices.size(), vector<int>(2 * k + 1, 0));
        for (int j = 1; j < 2 * k; j += 2) {
            dp[0][j] = -prices[0];
        }
        for (int i = 1;i < prices.size(); i++) {
            for (int j = 0; j < 2 * k - 1; j += 2) {
                dp[i][j + 1] = max(dp[i - 1][j + 1], dp[i - 1][j] - prices[i]);
                dp[i][j + 2] = max(dp[i - 1][j + 2], dp[i - 1][j + 1] + prices[i]);
            }
        }
        return dp[prices.size() - 1][2 * k];
    }
};
```

---

再来一个变种，就是如果我们买卖股票的次数是不限制的，但是有冷冻期，也就是卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。

现在，我们可以这样设置我们的状态:

+ 状态0： 持有态
+ 状态1： 未持有态
+ 状态2： 当天卖出态
+ 状态3： 冷冻期

为什么要加入状态2，按道理状态2应该被包括在了状态1？主要就是因为有这个冷冻期，不然我们无法区别如何进入状态3。

1. 确定递推公式

**达到买入股票状态**（状态一）即：dp\[i][0]，有两个具体操作：

- 操作一：前一天就是持有股票状态（状态一），dp\[i][0] = dp\[i - 1][0]
- 操作二：今天买入了，有两种情况
  - 前一天是冷冻期（状态四），dp\[i - 1][3] - prices[i]
  - 前一天是保持卖出股票的状态（状态二），dp\[i - 1][1] - prices[i]

那么dp[i][0] = max(dp\[i - 1][0], dp\[i - 1][3] - prices[i], dp\[i - 1][1] - prices[i]);

**达到保持卖出股票状态**（状态二）即：dp\[i][1]，有两个具体操作：

- 操作一：前一天就是状态二
- 操作二：前一天是冷冻期（状态四）

dp[i][1] = max(dp\[i - 1][1], dp\[i - 1][3]);

**达到今天就卖出股票状态**（状态三），即：dp\[i][2] ，只有一个操作：

昨天一定是持有股票状态（状态一），今天卖出

即：dp\[i][2] = dp\[i - 1][0] + prices[i];

**达到冷冻期状态**（状态四），即：dp\[i][3]，只有一个操作：

昨天卖出了股票（状态三）

dp\[i][3] = dp\[i - 1][2];

所以递推如下:
```c++
dp[i][0] = max(dp[i - 1][0], max(dp[i - 1][3], dp[i - 1][1]) - prices[i]);
dp[i][1] = max(dp[i - 1][1], dp[i - 1][3]);
dp[i][2] = dp[i - 1][0] + prices[i];
dp[i][3] = dp[i - 1][2];
```

**如何初始化呢？**

其实对于如何初始化，我们可以先代入一下递推公式

> 这里主要讨论一下第0天如何初始化。
>
> 如果是持有股票状态（状态一）那么：dp\[0][0] = -prices[0]，一定是当天买入股票。
>
> 保持卖出股票状态（状态二），这里其实从 「状态二」的定义来说 ，很难明确应该初始多少，这种情况我们就看递推公式需要我们给他初始成什么数值。
>
> 如果i为1，第1天买入股票，那么递归公式中需要计算 dp\[i - 1][1] - prices[i] ，即 dp\[0][1] - prices[1]，那么大家感受一下 dp\[0][1] （即第0天的状态二）应该初始成多少，只能初始为0。想一想如果初始为其他数值，是我们第1天买入股票后 手里还剩的现金数量是不是就不对了。
>
> 今天卖出了股票（状态三），同上分析，dp\[0][2]初始化为0，dp\[0][3]也初始为0。

最后结果是取 状态二，状态三，和状态四的最大值(状态一是持有态，肯定是没有卖出后的收益好).

