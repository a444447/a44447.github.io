# MySQL

## 存储引擎 InnoDB

关系型数据库中，我们认为表是一行行记录组成的，但是实际上表也是一个逻辑层面的组织结构，在实际的物理存储中，这些表中的数据是如何存储又是什么结构呢？

在MySQL中，负责对表中的数据数据进行读取和写入工作的部分是`存储引擎`. 服务器又支持不同类型的存储引擎，比如`InnoDB`、`MyISAM`、`Memory`，不同存储引擎之间存储的格式一般是不同的。

### InnoDB 记录结构

`InnoDB`是一个将表中的数据存储到磁盘上的存储引擎，所以即使关机后重启我们的数据还是存在的。但是我们要知道处理数据的过程是需要把数据从磁盘加载到内存中的，如果是处理写入或者修改操作还需要把内存的内容刷新到磁盘上——而我们知道读写磁盘的速度非常慢，和内存读写差了几个数量级。如果每次要从表中获得数据的时候，只是一条条把记录从磁盘中读出来，那么就太慢了。

`InnoDB`采取的方式是：将数据划分为若干个页，以**页作为磁盘和内存之间交互的基本单位**，InnoDB中页的大小一般为 ***16\*** KB。也就是在一般情况下，一次最少从磁盘中读取16KB的内容到内存中，一次最少把内存中的16KB内容刷新到磁盘中。

我们平时以记录为单位往表里面添加数据，这些记录在磁盘上的存放方式也被称为`行格式`或者`记录格式`

InnoDB设计4种行格式Compact`、`Redundant`、`Dynamic`和`Compressed

#### compact

<img src="https://relph1119.github.io/mysql-learning-notes/images/04-01.png" alt="COMPACT行格式" style="zoom:70%;" />

 compact行格式分为了两个部分，分别是记录额外的信息，与记录真实数据

##### 记录的额外信息

所谓的 **额外记录**就是为了就是为了描述这条记录不得不添加的一些信息。变长字段长度列表`、`NULL值列表`和`记录头信息

**变长字节长度列表**指的是mysql中有`VARCHAR(M)`、`VARBINARY(M)`、各种`TEXT`类型，各种`BLOB`类型，这些类型中存储多少数据是不固定的，所以我们在存储真实数据的时候需要顺便把这些数据占用的字节数也存起来。

变长字段占用的存储空间分为两部分：

1. 真正的数据内容
2. 占用的字节数

对于变长字段的真实数据占用的字节数是按照列的顺序逆序排放的。注意变长字段长度列表中是不会保存NULL的变长字段的长度。

```
假设row1,row2长度是[0x01, 0x02]
那么在变长字段的长度列表是[0x02,0x01]。
```

**为什么要逆序放置变长字段的长度列表**

主要是「记录头信息」中指向下个记录的指针，指向的是下一条记录的「记录头信息」和「真实数据」之间的位置，好处就是左边读就是记录头信息，右边读就是真实数据。这样可以使得位置靠前的记录的真实数据和数据对应的字段长度信息可以同时在一个CPU Cache Line中，提高CPU Cache的命中率。

注意当数据表中没有变长字段的时候,表里的行格式就不会有「变长字段长度列表」了。

---

由于某些列可能会保存NULL值，如果把这些NULL值都保存在真实数据中比较浪费空间，所以compact行格式把这些NULL的列都存储到NULL值列表中。NULL值列表就是一个Bitmap，它逆序存储了这个列是否为null

当然，如果数据表的字段定义为NOT NULL的时候，这里表里行格式就不会有NULL值列表了。（所以设计数据库表的时候，建议把字段设置为NOT NULL，这样至少占用1字节空间）。

---

**记录头信息**：比如就包含了

+ Delete_mask:标识这个数据是否被删除，执行delete删除记录的时候，并不会真正删除记录，而是把这里的delete_mask设置为1.
+ next_record：下一条记录的位置——记录与记录之间是通过链表组织的。
+ record_type:当前记录的类型，0表示普通记录，1表示B+树非叶子节点记录，2表示最小记录，3表示最大记录。

##### 记录的真实数据

<img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/row_format/%E8%AE%B0%E5%BD%95%E7%9A%84%E7%9C%9F%E5%AE%9E%E6%95%B0%E6%8D%AE.png" alt="img" style="zoom:50%;" />

真实记录除了定义的字段外，还有三个隐藏字段，分别为：row_id、trx_id、roll_pointer

+ roll_id：如果建表的时候指定了主键或唯一约束列，那么就没有row_id隐藏字段了。如果既没有指定主键，又没有唯一约束就会生成这个隐藏字段
+ trx_id: 事务id，表示这个数据是由哪个事务生产的，必须的
+ roll_pointer: 记录上一个版本的指针，roll_pointer是必须的。

#### 行溢出

MySQL中磁盘和内存交互的基本单位是页，一个页的大小一般是16KB,但是对于一个`varchar(n)`类型它最多可以存储65532字节，所以这种时候一个页可能存储不了一条记录，这个时候就会触发行溢出，多的数据会存储到溢出页中。也就是真实数据处只会保存该列一部分数据，剩下的数据放在溢出页中，然后真实数据处用20字节存储指向溢出页的地址。



### InnoDB 页结构

`InnoDB`为了不同的目的而设计了许多种不同类型的`页`，比如存放表空间头部信息的页，存放`Insert Buffer`信息的页，存放`INODE`信息的页，存放`undo`日志信息的页。

对于存放记录的页叫INDEX页，也可以叫数据页。

<img src="https://relph1119.github.io/mysql-learning-notes/images/05-01.png" alt="img" style="zoom:50%;" />

| `File Header`        | 文件头部           | `38`字节 | 页的一些通用信息         |
| -------------------- | ------------------ | -------- | ------------------------ |
| `Page Header`        | 页面头部           | `56`字节 | 数据页专有的一些信息     |
| `Infimum + Supremum` | 最小记录和最大记录 | `26`字节 | 两个虚拟的行记录         |
| `User Records`       | 用户记录           | 不确定   | 实际存储的行记录内容     |
| `Free Space`         | 空闲空间           | 不确定   | 页中尚未使用的空间       |
| `Page Directory`     | 页面目录           | 不确定   | 页中的某些记录的相对位置 |
| `File Trailer`       | 文件尾部           | `8`字节  | 校验页是否完整           |

file header中有两个指针，分别指向上一个数据页和下一个数据页，连起来的页相当于一个双向链表。数据页主要是存储记录，数据页中的User Records主要是依靠主键的顺序组成单向链表。单向链表的插入、删除非常方便，但是检索的效率不高。

所以数据页中有一个页目录，起到记录索引的作用。

<img src="https://cdn.xiaolincoding.com//mysql/other/261011d237bec993821aa198b97ae8ce.png" alt="图片" style="zoom:50%;" />

页目录创建的过程如下：  

将所有的记录划分成几个组，这些记录包括最小记录和最大记录，但不包括标记为“已删除”的记录； 每个记录组的最后一条记录就是组内最大的那条记录，并且最后一条记录的头信息中会存储该组一共有多少条记录，作为 n_owned 字段（上图中粉红色字段） 页目录用来存储每组最后一条记录的地址偏移量，这些地址偏移量会按照先后顺序存储起来，每组的地址偏移量也被称之为槽（slot），每个槽相当于指针指向了不同组的最后一个记录。 从图可以看到，页目录就是由多个槽组成的，槽相当于分组记录的索引。然后，因为记录是按照「主键值」从小到大排序的，所以我们通过槽查找记录时，可以使用二分法快速定位要查询的记录在哪个槽（哪个记录分组），定位到槽后，再遍历槽内的所有记录，找到对应的记录，无需从最小记录开始遍历整个页中的记录链表。



## 索引

索引帮助存储引擎快速查找数据，是一种时间换空间的思想。
