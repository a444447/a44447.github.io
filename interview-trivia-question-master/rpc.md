# 概念

RPC是远程方法调用，现在RPC已经是分布式系统中重要的通信方式。RPC*允许一个程序调用另一个程序中的函数或方法，而无需了解网络的细节*。因此RPC的出现使得分布式系统中的各个组件之间的通信变得更加简单、高效和可信。

RPC 在很多思想与IPC很像。IPC是进程间通信，常用的技术是 **管道、消息队列、共享内存、信号量、socket等**。

**rpc**最开始的目的就是为了让计算机能够像调用本地方法一样调用远程方法！



![img](E:\githome\a44447.github.io\interview-trivia-question-master\assets\6361e5897dc6985f3898539f63b4ff4b.png)

![image-20250303005124710](E:\githome\a44447.github.io\interview-trivia-question-master\assets\image-20250303005124710.png)

这个图就描述了RPC调用的过程。



## why RPC?

1. 简化远程调用的复杂性

在分布式系统中，服务通常部署在不同的机器和网络中，如果没有RPC，开发人员需要自己实现复杂的网络通信代码：

+ 创建和管理连接
+ 数据的序列化与反序列化
+ 请求和响应的发送与接受
+ 错误处理

RPC对这些底层逻辑进行了封装，开发人员只需要专注于业务逻辑

2. RPC支持微服务架构

微服务架构的目标是，1）将功能拆分为独立的服务，降低模块之间的依赖 2） 各个服务可以独立扩展、部署和更新

但是微服务架构中，不同的服务可能是部署在不同的机器或网络环境，需要高效的通信手段，RPC就提供了：

+ 跨机器调用
+ 通过高效的序列化协议，比如Protobuf优化数据传输
+ 提供可靠性保证，内置重试机制、超时机制，确保服务通信的可靠性。

3. 提升开发效率

+ 抽象通信过程:通过使用RPC、开发人员只需定义远程调用的接口(如方法签名)，无需实现复杂的
  通信逻辑.
+ 统一接口定义:大多数rpc框架(如grpc)提供IDL(接口描述语言)，开发人员只需编写一份接
  口定义，框架会自动生成客户端和服务端代码.
+ 减少出错概率:通过框架封装复杂的通信逻辑，可以减少手动编写网络代码时的错误(如序列化失败、超时处理不当等)

### 实现一个rpc的前置知识

我们实现的rpc框架使用的序列化技术是Protobuf。rpc双方通信时发送的都是固定的结构，发送前用Protobuf把消息结构体二进制序列化，在接收方又把这个消息结构体反序列化。

设计的一个简单消息输出格式是这样的

```protobuf
syntax="proto3";
package Krpc;

message RpcHeader {
	bytes service_name=1;
	bytes method_name=2;
	uint32 args_size=3;
}
```

![image-20250303010841052](E:\githome\a44447.github.io\interview-trivia-question-master\assets\image-20250303010841052.png)

因为参数是可变的，所以不能直接封装进RpcHeader,只能封装参数的数量，然后来解析。



### rpc异步与同步调用

#### 同步

同步调用就是在得到结果之前，一直处于阻塞状态，会一直占用一个工作线程。

![RPC client同步调用](https://obsdian-1304266993.cos.ap-chongqing.myqcloud.com/202503031711202.png)

(1)业务代码发起RPC调用，Result=Add(Obj1,Obj2)

(2) 序列化组件，将对象调用序列化成二进制字节流，可理解为一个待发送的包packet1
(3) 通过连接池组件拿到一个可用的连接connection
(4) 通过连接connection将包packet1发送给RPC-server
(5) 发送包在网络传输，发给RPC-server
(6) 响应包在网络传输，发回给RPC-client
(7) 通过连接connection从RPC-server收取响应包packet2
(8) 通过连接池组件，将conneciont放回连接池
(9) 序列化组件，将packet2反序列化为Result对象返回给调用方
(10) 业务代码获取Result结果，工作线程继续往下走

#### 异步

所谓异步回调，在得到结果之前，不会处于阻塞状态，理论上任何时间都没有任何线程处于阻塞状态，因此异步回调的模型，理论上只需要很少的工作线程与服务连接就能够达到很高的吞吐量。

与同步的RPC设计相比，异步的rpc多了上下文管理器，超时管理器，下游收发队列，下游收发线程结构

(1) 业务代码发起异步RPC调用，Add(Obj1, Obj2, callback)；
(2) 上下文管理器，将请求、回调、上下文存储起来；
(3) 序列化组件，将对象调用序列化为二进制字节流，可以理解为一个待发送的包Packet1；
(4) 下游收发队列，将报文放入"待发送队列"，此时调用返回，不会阻塞工作线程；
(5) 下游收发线程，将报文从待发送队列中取出，通过连接池组件获取一个可用的连接connection；
(6) 通过连接connection将报Packet1发送给RPC server；
(7) 发送包在网络传输，发给RPC server；
(8) 响应包在网络传输，发回给RPC client；
(9) 通过连接connection从RPC server收取响应包Packet2；
(10) 下游收发线程，将报文放入已接收队列，通过连接池组件，将connection放回连接池；
(11) 下游收发队列里，报文取出，此时回调将要开始，不会阻塞工作线程；
(12) 序列化组件，将Packet2反序列化为Result对象；
(13) 上下文管理器，将结果回调，上下文取出；
(14) 通过callback回调业务代码，返回Result结果，工作线程继续往下走；
**如果请求长时间不返回，处理流程为：**
(15) 上下文管理器，请求长时间没有返回；
(16) 超时管理器拿到超时的上下文；
(17) 通过timeout_cb回调业务代码，工作线程继续执行；

---

这个上下文管理器很重要，因为相应包的回调是异步的，甚至不在一个工作线程中，因此要有一个组建来记录请求的上下文，把请求-响应-回调等信息匹配起来

**如何匹配？**

假设通过一条连接向下游服务发送了a,b,c三个请求包，异步的收到了x,y,z三个相应包：

(1) 如何知道哪个请求包对应哪个响应包？
(2) 如何知道哪个响应包与哪个回调函数对应？

方法是有一个请求ID

![异步请求关联](https://obsdian-1304266993.cos.ap-chongqing.myqcloud.com/202503031718472.png)

整个处理流程如上，通过请求id，上下文管理器来对应请求-响应-callback之间的映射关系：
(1) 生成请求id；
(2) 生成请求上下文context，上下文中包含发送时间time，回调函数callback等信息；
(3) 上下文管理器记录req-id与上下文context的映射关系；
(4) 将req-id打在请求包里发给RPC-server；
(5) RPC-server将req-id打在响应包里返回；
(6) 由响应包中的req-id，通过上下文管理器找到原来的上下文context；
(7) 从上下文context中拿到回调函数callback；
(8) callback将Result带回，推动业务的进一步执行；

---

**如何实现超时发送和接受？超时管理器**

![超时管理器](https://obsdian-1304266993.cos.ap-chongqing.myqcloud.com/202503031719757.png)

超时管理器，用于实现请求回包超时回调处理。
每一个请求发送给下游RPC server，会在上下文管理器中保存req id与上下文的信息，上下文中保存了请求很多相关信息，例如req id，回包回调，超时回调，发送时间等。**超时管理器启动timer**对上下文管理器中的context进行扫描，看上下文中请求发送时间是否过长，如果过长，就不再等待回包，直接超时回调，推动业务流程继续往下走，并将上下文删除。如果超时回调执行后，正常的回包又到达，通过req id在上下文管理器里找不到上下文，就直接将请求丢弃（因为已经超时处理过了）。

### protobuf学习

